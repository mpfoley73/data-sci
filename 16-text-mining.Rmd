# Text Mining

```{r message=FALSE, warning=FALSE, echo=FALSE}
library(tidyverse)
library(tidytext)
library(janeaustenr)
library(gutenbergr)
library(scales)
library(wordcloud)
library(igraph)
library(ggraph)
library(widyr)
library(tm)
library(gridExtra)
```

Text mining may be thought of as the process of distilling actionable insights from text, typically by identifying patterns with statistical pattern learning. Typical text mining tasks include text categorization, sentiment analysis, and topic modeling.  

There are two approaches to text mining.  *Semantic parsing* identifies words by type and order (sentences, phrases, nouns/verbs, proper nouns, etc.).  *Bag of Words* treats words as simply attributes of the document.  Bag of words is obviously the simpler way to go.

The **qdap** package provides parsing tools for preparing transcript data. 
```{r warning=FALSE, message=FALSE}
library(qdap)
```

For example, `freq_terms()` parses text and counts the terms.

```{r}
freq_terms(DATA$state, top = 5)
```

You can also plot the terms.

```{r}
plot(freq_terms(DATA$state, top = 5))
```

There are two kinds of the corpus data types, the permanent corpus, **PCorpus**, and the volatile corpus, **VCorpus**. The volatile corpus is held in RAM rather than saved to disk.  Create a volatile corpus with `tm::vCorpous()`. vCorpous() takes either a text source created with `tm::VectorSource()` or a dataframe source created with `Dataframe Source()` where the input dataframe has cols `doc_id`, `text_id` and zero or more metadata columns.

```{r}
tweets <- read_csv(file = "https://assets.datacamp.com/production/repositories/19/datasets/27a2a8587eff17add54f4ba288e770e235ea3325/coffee.csv")
coffee_tweets <- tweets$text

coffee_source <- VectorSource(coffee_tweets)
coffee_corpus <- VCorpus(coffee_source)

# Text of first tweet
coffee_corpus[[1]][1]
```

In bag of words text mining, cleaning helps aggregate terms, especially words with common stems like "miner" and "mining".  There are several functions useful for preprocessing: `tolower()`, `tm::removePunctuation()`, `tm::removeNumbers()`, `tm::stripWhiteSpace()`, and `removeWords()`.  Apply these functions to the documents in a `VCorpus` object with `tm_map()`.  If the function is not one of the pre-defined functions, wrap it in `content_transformer()`.  Another preprocessing function is `stemDocument()`.

```{r}
# Create the object: text
text <- "<b>She</b> woke up at       6 A.M. It\'s so early!  She was only 10% awake and began drinking coffee in front of her computer."
tolower(text)
removePunctuation(text)
removeNumbers(text)
stripWhitespace(text)
```

The **qdap** package offers other preprocessing functions.

```{r}
text <- "<b>She</b> woke up at       6 A.M. It\'s so early!  She was only 10% awake and began drinking coffee in front of her computer."
bracketX(text)
replace_number(text)
replace_abbreviation(text)
replace_contraction(text)
replace_symbol(text)
```

`tm::stopwords("en")` returns a vector of stop words.  You can add to the list with concatenation.

```{r}
new_stops <- c("coffee", "bean", stopwords("en"))
removeWords(text, new_stops)
```

`tm::stemDocument()` and `tm::stemCompletion()` reduce the variation in terms.

```{r}
complicate <- c("complicated", "complication", "complicatedly")

stem_doc <- stemDocument(complicate)

comp_dict <- c("complicate")

complete_text <- stemCompletion(stem_doc, comp_dict)
complete_text
```


```{r}
clean_corpus <- function(corpus){
  corpus <- tm_map(corpus, removePunctuation)
  corpus <- tm_map(corpus, content_transformer(tolower))
  corpus <- tm_map(corpus, removeWords, words = c(stopwords("en"), "coffee", "mug"))
  corpus <- tm_map(corpus, stripWhitespace)
  return(corpus)
}
clean_corp <- clean_corpus(coffee_corpus)
content(clean_corp[[1]])

# compare to original
content(coffee_corpus[[1]])
```

To perform the analysis of the tweets, convert the corpus into either a document term matrix (DTM, documents as rows, terms as cols), or a term document matrix (TDM, terms as rows, documents as cols). 

```{r}
coffee_tdm <- TermDocumentMatrix(clean_corp)

# Print coffee_tdm data
coffee_tdm

# Convert coffee_tdm to a matrix
coffee_m <- as.matrix(coffee_tdm)

# Print the dimensions of the matrix
dim(coffee_m)

# Review a portion of the matrix
coffee_m[c("star", "starbucks"), 25:35]
```

# Tidy Text

The tidy text format is a table with one token (meaningful unit of text, such as a word) per row.  The `tidytext` package assists with the major tasks in text analysis.  A typical text analysis using tidy data principles unnests tokens with `unnest_tokens()`, removes unimportant "stop words" tokens `anti_join(stop_words)`, and summarizes token counts `count()`.

Here are four Jane Austin books from the `janeaustenr`. "Sense & Sensibility" acts as the baseline count, and the other books are faceted for comparison.  Note the use of the "tribble" of custom stop words.

```{r}
custom_stop_words <- tribble(
  ~word, ~lexicon,
  "edward", "CUSTOM",
  "frank", "CUSTOM",
  "thomas", "CUSTOM",
  "fanny", "CUSTOM",
  "anne", "CUSTOM"
)

austin_tidy <- austen_books() %>%
  group_by(book) %>%
  mutate(
    linenumber = row_number(),
    chapter = cumsum(str_detect(text, regex("^chapter [\\divxlc]", ignore_case = TRUE)))
    ) %>%
  ungroup() %>%
  unnest_tokens(output = word, input = text) %>%
  anti_join(stop_words) %>%
  anti_join(custom_stop_words)

austin_tidy %>%
  count(book, word) %>%
  group_by(book) %>%
  mutate(proportion = n / sum(n)) %>% 
  select(-n) %>% 
  pivot_wider(names_from = book, values_from = proportion) %>%
  pivot_longer(cols = `Pride & Prejudice`:`Persuasion`, names_to = "book", values_to = "proportion") %>%
  ggplot(aes(x = proportion, 
             y = `Sense & Sensibility`,
             color = abs(`Sense & Sensibility` - proportion))) +
  geom_abline(color = "gray40", lty = 2) +
  geom_jitter(alpha = 0.1, size = 2.5, width = 0.3, height = 0.3) +
  geom_text(aes(label = word), check_overlap = TRUE, vjust = 1.5) +
  scale_x_log10(labels = percent_format()) +
  scale_y_log10(labels = percent_format()) +
  scale_color_gradient(limits = c(0, 0.001), low = "darkslategray4", high = "gray75") +
  facet_wrap(~book, ncol = 2) +
  theme(legend.position = "none") +
  labs(y = "Sense & Sensibility", x = NULL)
```

Words close to the 45-degree lines have similar frequencies in both books.  Words far from the line are found more in one book more than the other.  If there are few points near the low frequencies, then few infrequent words are shared.  Emma is similar to Sense & Sensibility because the points are fairly narrow on the 45-degree line, and they extend all the way to the origin.

A common way to visualize words is with a word cloud.  The `wordcloud` library is helpful.  NOte that word clouds do not contain any information not already in a bar plot.

```{r}
austin_word_cnt <- austin_tidy %>%
  filter(book == "Sense & Sensibility") %>%
  count(word)
pal <- brewer.pal(9,"BuGn")
pal <- pal[-(1:4)]
wordcloud(
  words = austin_word_cnt$word,
  freq = austin_word_cnt$n,
  max.words = 30,
  colors = pal
)
```

```{r}
# pa_file <- readxl::read_excel("./../../PeoplaAnalyticsCloud.xlsx")
# pa_tidy <- pa_file %>%
#   mutate(
#     linenumber = row_number(),
#     ) %>%
#   ungroup() %>%
#   unnest_tokens(output = word, input = comment) %>%
# #  unnest_tokens(output = bigram, input = comment, token = "ngrams", n = 2) 
#   anti_join(stop_words) %>%
#   anti_join(custom_stop_words)
# pa_tidy_n <- pa_tidy %>%
#   count(word)
# pal <- brewer.pal(9,"BuGn")
# pal <- pal[-(1:4)]
# wordcloud(
#   words = pa_tidy_n$word,
#   freq = pa_tidy_n$n,
#   max.words = 30,
#   colors = pal
# )
# 
# pa_2gram <- pa_tidy %>%
#   separate(bigram, c("word1", "word2"), sep = " ") %>%
#   filter(!word1 %in% stop_words$word &
#            !word2 %in% stop_words$word &
#            !is.na(word1) & !is.na(word2)) %>%
#   unite(bigram, word1, word2, sep = " ")
# 
# 
# pa_2gram %>%
#   count(book, bigram, sort = TRUE)
# 
# pa_2gram2 <- pa_2gram %>%
#   count(bigram)
# pal <- brewer.pal(9,"BuGn")
# pal <- pal[-(1:4)]
# wordcloud(
#   words = pa_2gram2$bigram,
#   freq = pa_2gram2$n,
#   max.words = 30,
#   colors = pal
# )
```


# Bag of Words
# Sentiment Analysis

A typical sentiment analysis involves unnesting tokens with `unnest_tokens()`, assigning sentiments with `inner_join(sentiments)`, counting tokens with `count()`, and summarizing and visualizing.

The tidytext package contains four sentiment lexicons, all based on unigrams. 

* **nrc**. binary “yes”/“no” for categories positive, negative, anger, anticipation, disgust, fear, joy, sadness, surprise, and trust. 
* **bing**. “positive”/“negative” classification. 
* **AFINN**. score between -5 (most negative) and 5 (most positive).
* **loughran**. "positive"/"negative"/"litigious"/"uncertainty"/"constraining"/"superflous" classification.

You can view the sentiment assignments with `get_sentiments(lexicon = c("afinn", "bing", nrc", "laughlin"))`

```{r}
x1 <- get_sentiments(lexicon = "nrc") %>%
  count(sentiment) %>%
  mutate(lexicon = "nrc")
x2 <- get_sentiments(lexicon = "bing") %>%
  count(sentiment) %>%
  mutate(lexicon = "bing")
x3 <- get_sentiments(lexicon = "afinn") %>%
  count(value) %>%
  mutate(lexicon = "afinn") %>%
  mutate(sentiment = as.character(value)) %>%
  select(-value)
x4 <- get_sentiments(lexicon = "loughran") %>%
  count(sentiment) %>%
  mutate(lexicon = "loughran")
x <- bind_rows(x1, x2, x3, x4)

ggplot(x, aes(x = fct_reorder(sentiment, n), y = n, fill = lexicon)) +
  geom_col(show.legend = FALSE) +
  coord_flip() +
  labs(title = "Sentiment Counts", x = "", y = "") +
  facet_wrap(~ lexicon, scales = "free")
```

Here is a sentiment analysis of sections of 80 lines of Jane Austin's books.  *(Small sections may not have enough words to get a good estimate of sentiment, and large sections can wash out the narrative structure.  80 lines seems about right.)*

```{r}
austin_tidy %>%
  inner_join(get_sentiments("bing")) %>%
  count(book, index = linenumber %/% 80, sentiment) %>%
  pivot_wider(names_from = sentiment, values_from = n, values_fill = list(n = 0)) %>%
  mutate(sentiment = positive - negative) %>%
  ggplot(aes(x = index, y = sentiment, fill = book)) +
  geom_col(show.legend = FALSE) +
  facet_wrap(~book, ncol = 2, scales = "free_x")
```

Fair to say Jane Austin novels tend to have a happy ending?  The three sentiment lexicons provide different views of THE data.  Here is a comparison of the lexicons using one of Jane Austin's novels, "Pride and Prejudice".

```{r}
# AFINN lexicon measures sentiment with a numeric score between -5 and 5.
afinn <- austin_tidy %>% 
  filter(book == "Pride & Prejudice") %>%
  inner_join(get_sentiments("afinn"), by = "word") %>% 
  group_by(index = linenumber %/% 80) %>% 
  summarise(sentiment = sum(value)) %>% 
  mutate(method = "AFINN")

# Bing and nrc categorize words in a binary fashion, either positive or negative.
bing <- austin_tidy %>%
  filter(book == "Pride & Prejudice") %>%
  inner_join(get_sentiments("bing"), by = "word") %>% 
  count(index = linenumber %/% 80, sentiment) %>%
  pivot_wider(names_from = sentiment, values_from =  n, values_fill = list(n = 0)) %>%
  mutate(sentiment = positive - negative) %>% 
  mutate(method = "Bing") %>%
  select(index, sentiment, method)

nrc <- austin_tidy %>%
  filter(book == "Pride & Prejudice") %>%
  inner_join(get_sentiments("nrc") %>% filter(sentiment %in% c("positive", "negative")), by = "word") %>% 
  count(index = linenumber %/% 80, sentiment) %>%
  pivot_wider(names_from = sentiment, values_from = n, values_fill = list(n = 0)) %>%
  mutate(sentiment = positive - negative) %>% 
  mutate(method = "NRC") %>%
  select(index, sentiment, method)

bind_rows(afinn, bing, nrc) %>%
  ggplot(aes(index, sentiment, fill = method)) +
  geom_col(show.legend = FALSE) +
  facet_wrap(~method, ncol = 1, scales = "free_y")
```

In this example, and in general, **NRC** sentiment tends to be high, **AFINN** sentiment has more variance, and **Bing** sentiment finds longer stretches of similar text.  However, all three agree roughly on the overall trends in the sentiment through a narrative arc.

What are the top-10 positive and negative words?  Using the Bing lexicon, get the counts, then `group_by(sentiment)` and `top_n()` to the top 10 in each category.  

```{r}
austin_tidy %>%
  filter(book == "Pride & Prejudice") %>%
  inner_join(get_sentiments("bing"), by = "word") %>% 
  count(word, sentiment, sort = TRUE) %>%
  group_by(sentiment) %>%
  top_n(n = 10, wt = n) %>%
  ggplot(aes(x = fct_reorder(word, n), y = n, fill = sentiment)) +
  geom_col(show.legend = FALSE) +
  facet_wrap(~sentiment, scales = "free_y") +
  coord_flip() +
  labs(y = "Contribution to Sentiment",
       x = "")
```

Uh oh, "miss" is a red-herring - in Jane Austin novels it often refers to an unmarried woman.  Drop it from the analysis by appending it to the stop-words list.

```{r}
austin_tidy %>%
  anti_join(bind_rows(stop_words,
                      tibble(word = c("miss"), lexicon = c("custom")))) %>%
  filter(book == "Pride & Prejudice") %>%
  inner_join(get_sentiments("bing")) %>% 
  count(word, sentiment, sort = TRUE) %>%
  group_by(sentiment) %>%
  top_n(n = 10, wt = n) %>%
  ggplot(aes(x = fct_reorder(word, n), y = n, fill = sentiment)) +
  geom_col(show.legend = FALSE) +
  facet_wrap(~sentiment, scales = "free_y") +
  coord_flip() +
  labs(y = "Contribution to Sentiment",
       x = "")
```

Better!

A common way to visualize sentiments is with a word cloud.  

```{r}
austin_tidy %>%
  anti_join(bind_rows(stop_words,
                      tibble(word = c("miss"), lexicon = c("custom")))) %>%
  filter(book == "Pride & Prejudice") %>%
  count(word) %>%
  with(wordcloud(word, n, max.words = 100))
```

`comparison.cloud` is another implementation of a word cloud.  It takes a matrix input.

```{r}
x <- austin_tidy %>%
  anti_join(bind_rows(stop_words,
                      tibble(word = c("miss"), lexicon = c("custom")))) %>%
  inner_join(get_sentiments("bing")) %>% 
  filter(book == "Pride & Prejudice") %>%
  count(word, sentiment, sort = TRUE) %>%
  pivot_wider(names_from = sentiment, values_from = n, values_fill = list(n = 0)) %>%
  as.data.frame()
rownames(x) <- x[,1]
comparison.cloud(x[, 2:3])
rm(x)
```

Sometimes it makes more sense to analyze entire sentences.  Specify `unnest_tokens(..., token = "sentences")` to override the default `token = "word"`.

```{r}
austen_books() %>%
  group_by(book) %>%
  mutate(linenumber = row_number(),
         chapter = cumsum(str_detect(text, regex("^chapter [\\divxlc]",
                                                 ignore_case = TRUE)))) %>%
  ungroup() %>%
  unnest_tokens(output = word, input = text, token = "sentences")

```

## N-Grams

Create n-grams by specifying `unnest_tokens(..., token = "ngrams", n)` where `n = 2` is a bigram, etc.  To remove the stop words, `separate` the n-grams, then filter on the `stop_words` data set.

```{r}
austin.2gram <- austen_books() %>%
  group_by(book) %>%
  mutate(linenumber = row_number(),
         chapter = cumsum(str_detect(text, regex("^chapter [\\divxlc]",
                                                 ignore_case = TRUE)))) %>%
  ungroup() %>%
  unnest_tokens(output = bigram, input = text, token = "ngrams", n = 2)

austin.2gram <- austin.2gram %>%
  separate(bigram, c("word1", "word2"), sep = " ") %>%
  filter(!word1 %in% stop_words$word &
           !word2 %in% stop_words$word &
           !is.na(word1) & !is.na(word2)) %>%
  unite(bigram, word1, word2, sep = " ")

austin.2gram %>%
  count(book, bigram, sort = TRUE)
```

Here are the most commonly mentioned streets in Austin's novels.

```{r}
austin.2gram %>%
  separate(bigram, c("word1", "word2"), sep = " ") %>%
  filter(word2 == "street") %>%
  count(book, word1, sort = TRUE)
```


Bind the tf-idf statistics.  Tf-idf is short for term frequency–inverse document frequency.  It is a statistic that indicates how important a word is to a document in a collection or corpus. Tf–idf increases with the number of times a word appears in the document and decreases with the number of documents in the corpus that contain the word.  The idf adjusts for the fact that some words appear more frequently in general.

```{r}
austen_books() %>%
  group_by(book) %>%
  mutate(linenumber = row_number(),
         chapter = cumsum(str_detect(text, regex("^chapter [\\divxlc]",
                                                 ignore_case = TRUE)))) %>%
  ungroup() %>%
  unnest_tokens(output = bigram, input = text, token = "ngrams", n = 2) %>%
  separate(bigram, c("word1", "word2"), sep = " ") %>%
  filter(!word1 %in% stop_words$word &
           !word2 %in% stop_words$word &
           !is.na(word1) & !is.na(word2)) %>%
  unite(bigram, word1, word2, sep = " ")
austin.2gram %>%
  count(book, bigram) %>%
  bind_tf_idf(bigram, book, n) %>%
  group_by(book) %>%
  top_n(n = 10, wt = tf_idf) %>%
  ggplot(aes(x = fct_reorder(bigram, n), y = tf_idf, fill = book)) +
  geom_col(show.legend = FALSE) +
  facet_wrap(~book, scales = "free_y", ncol = 2) +
  labs(y = "tf-idf of bigram to novel") +
  coord_flip() 
```


A good way to visualize bigrams is with a network graph.  Packages `igraph` and `ggraph` provides tools for this purpose.

```{r}
set.seed(2016)

austen_books() %>%
  group_by(book) %>%
  mutate(linenumber = row_number(),
         chapter = cumsum(str_detect(text, regex("^chapter [\\divxlc]",
                                                 ignore_case = TRUE)))) %>%
  ungroup() %>%
  unnest_tokens(output = bigram, input = text, token = "ngrams", n = 2) %>%
  separate(bigram, c("word1", "word2"), sep = " ") %>%
  filter(!word1 %in% stop_words$word &
           !word2 %in% stop_words$word &
           !is.na(word1) & !is.na(word2)) %>%
  count(word1, word2) %>%
  filter(n > 20) %>%
  graph_from_data_frame() %>%  # creates unformatted "graph"
  ggraph(layout = "fr") +
  geom_edge_link(aes(edge_alpha = n), 
                 show.legend = FALSE,
                 arrow = grid::arrow(type = "closed", 
                                     length = unit(.15, "inches")), 
                 end_cap = circle(.07, 'inches')) +
  geom_node_point(color = "lightblue", 
                  size = 5) +
  geom_node_text(aes(label = name), vjust = 1, hjust = 1) +
  theme_void()
```


If you want to count the number of times that two words appear within the same document, or to see how correlated they are, widen the data with the `widyr` package.

```{r}
austen_books() %>%
  filter(book == "Pride & Prejudice") %>%
  mutate(section = row_number() %/% 10) %>%
  filter(section > 0) %>%
  unnest_tokens(word, text) %>%
  filter(!word %in% stop_words$word) %>%
  pairwise_count(word, section, sort = TRUE)
```

The correlation among words is how often they appear together relative to how often they appear separately.  The phi coefficient is defined

$$\phi = \frac{n_{11}n_{00} - n_{10}n_{01}}{\sqrt{n_{1.}n_{0.}n_{.1}n_{.0}}}$$

where $n_{10}$ means number of times section has word x, but not word y, and $n_{1.}$ means total times section has word x.  This lets us pick particular interesting words and find the other words most associated with them.

```{r}
austen_books() %>%
  filter(book == "Pride & Prejudice") %>%
  mutate(section = row_number() %/% 10) %>%
  filter(section > 0) %>%
  unnest_tokens(word, text) %>%
  filter(!word %in% stop_words$word) %>%
  pairwise_cor(word, section, sort = TRUE) %>%
  filter(item1 %in% c("elizabeth", "pounds", "married", "pride")) %>%
  group_by(item1) %>%
  top_n(n = 4) %>%
  ungroup() %>%
  mutate(item2 = reorder(item2, correlation)) %>%
  ggplot(aes(x = item2, y = correlation)) +
  geom_bar(stat = "identity") +
  facet_wrap(~ item1, scales = "free") +
  coord_flip()
```

You can use the correlation to set a threshold for a graph.

```{r}
set.seed(2016)

austen_books() %>%
  filter(book == "Pride & Prejudice") %>%
  mutate(section = row_number() %/% 10) %>%
  filter(section > 0) %>%
  unnest_tokens(word, text) %>%
  filter(!word %in% stop_words$word) %>%
  # filter to relatively common words
  group_by(word) %>%
  filter(n() > 20) %>%
  pairwise_cor(word, section, sort = TRUE) %>%
  filter(correlation > .15) %>%  # relatively correlated words
  graph_from_data_frame() %>%
  ggraph(layout = "fr") +
  geom_edge_link(aes(edge_alpha = correlation), show.legend = FALSE) +
  geom_node_point(color = "lightblue", size = 5) +
  geom_node_text(aes(label = name), repel = TRUE) +
  theme_void()
```


## Converting to and from non-tidy formats

One of the most common objects in text mining packages is the document term matrix (DTM) where each row is a document, each column a term, and each value an appearance count.  The `broom` package contains functions to convert between DTM and tidy formats.

Convert a DTM object into a tidy data frame with `tidy()`.  Convert a tidy object into a sparse matrix with `cast_sparse()`, into a DTM with `cast_dtm()`, and into a "dfm" for quanteda with `cast_dfm()`.  

```{r}
data("AssociatedPress", package = "topicmodels")
AssociatedPress
Terms(AssociatedPress) %>% head()
```

Create a tidy version of `AssociatedPress` with `tidy()`.

```{r}
ap_td <- tidy(AssociatedPress)
ap_td %>% 
  inner_join(get_sentiments("bing"), by = c(term = "word")) %>%
  count(sentiment, term, wt = count) %>%
  ungroup() %>%
  filter(n >= 200) %>%
  mutate(n = ifelse(sentiment == "negative", -n, n)) %>%
  arrange(n) %>%
  ggplot(aes(x = fct_inorder(term), y = n, fill = sentiment)) +
  geom_bar(stat = "identity") +
  labs(title = "Most Common AP Sentiment Words",
       x = "",
       y = "Contribution to Sentiment") +
  theme(legend.position = "top", 
        legend.title = element_blank()) +
  coord_flip()
```

The document-feature matrix `dfm` class from the `quanteda` text-mining package is another implementation of a document-term matrix.  Here are the terms most specific (highest tf-idf) from each of four selected inaugural addresses.  

```{r}
data("data_corpus_inaugural", package = "quanteda")
inaug_dfm <- quanteda::dfm(data_corpus_inaugural, verbose = FALSE)
head(inaug_dfm)

inaug_td <- tidy(inaug_dfm)
head(inaug_td)

inaug_td %>% 
  bind_tf_idf(term = term, document = document, n = count) %>%
  group_by(document) %>%
  top_n(n = 10, wt = tf_idf) %>%
  ungroup() %>%
  filter(document %in% c("1861-Lincoln", "1933-Roosevelt", "1961-Kennedy", "2009-Obama")) %>%
  arrange(document, desc(tf_idf)) %>%
  ggplot(aes(x = fct_rev(fct_inorder(term)), y = tf_idf, fill = document)) +
  geom_col() +
  labs(x = "") +
  theme(legend.position = "none") +
  coord_flip() +
  facet_wrap(~document, ncol = 2, scales = "free")
```

And here is word frequency trend ocer time for six selected terms.

```{r}
inaug_td %>%
  extract(document, "year", "(\\d+)", convert = TRUE) %>%
  complete(year, term, fill = list(count = 0)) %>%
  group_by(year) %>%
  mutate(year_total = sum(count)) %>%
  filter(term %in% c("god", "america", "foreign", "union", "constitution", "freedom")) %>%
  ggplot(aes(x = year, y = count / year_total)) + 
  geom_point() +
  geom_smooth() +
  facet_wrap(~ term, scales = "free_y") +
  scale_y_continuous(labels = scales::percent_format()) +
  labs(y = "",
       title = "% frequency of word in inaugural address")
```

Cast tidy data into document-term matrix with `cast_dtm()`, quanteda's dfm with `cast_dfm()`, and sparese matrix with `cast_sparse()`.

```{r}
inaug_dtm <- cast_dtm(data = inaug_td, document = document, term = term, value = count)
inaug_dfm <- cast_dfm(data = inaug_td, document = document, term = term, value = count)
inaug_sparse <- cast_sparse(data = inaug_td, row = document, column = term, value = count)
```

An untokenized document collection is called a *corpus*. The corpuse may include metadata, such as ID, date/time, title, language, etc.  Corpus metadata is usually stored as lists.  Use `tidy()` to construct a table, one row per document.

```{r}
data("acq")
print(acq)
acq[[1]]  # first document

acq_td <- tidy(acq)
acq_td
```

## Example

Library `tm.plugin.webmining` connects to online feeds to retrieve news articles based on a keyword.

```{r}
library(tm.plugin.webmining)
library(purrr)

company <- c("Progressive", "Microsoft", "Apple")
symbol <- c("PRG", "MSFT", "AAPL")
download_articles <- function(symbol) {
  WebCorpus(GoogleFinanceSource(paste0("NASDAQ:", symbol)))
}
#stock_articles <- tibble(company = company,
#                         symbol = symbol) %>%
#  mutate(corpus = map(symbol, download_articles))
#download_articles("MSFT")
#?GoogleFinanceSource()
#corpus <- Corpus(GoogleFinanceSource("NASDAQ:MSFT"))
```

# Topic Modeling

Topic modeling is a method for unsupervised classification of documents, similar to clustering on numeric data, which finds natural groups of items.  Latent Dirichlet allocation (LDA) is a popular topic modeling algorithm. LDA treats each document as a mixture of topics (X% topic A, Y% topic B, etc.), and each topic as a mixture of words.  Each topic is a collection of word probabilities for all of the unique words used in the corpus. LDA is implemented in the `topicmodels` package.

```{r message=FALSE, warning=FALSE}
library(topicmodels)
```

Create a topic model with the `LDA` function.  Parameter `k` specifieds the number of topics.  Here is an example using the `AssociatedPress` data set.

```{r cache=TRUE}
data("AssociatedPress")

ap_lda <- LDA(AssociatedPress, k = 2, control = list(seed = 1234))
```

The tidytext package provides a tidy method for extracting the per-topic/word probabilities, called $\beta$ from the model.

```{r}
library(tidytext)

ap_topics <- tidy(ap_lda, matrix = "beta")

ap_topics %>% arrange(-beta)
```

The tidied format lends itself to plotting.

```{r}
ap_topics %>%
  group_by(topic) %>%
  top_n(n = 10, wt = beta) %>%
  ungroup() %>%
  arrange(topic, -beta) %>%
  mutate(term = reorder_within(term, beta, topic)) %>%
  ggplot(aes(x = term, y = beta, fill = factor(topic))) +
  geom_col(show.legend = FALSE) +
  facet_wrap(~ topic, scales = "free") +
  coord_flip() +
  scale_x_reordered()
```

Topic 1 appears to be related to the economy; topic 2 to politics.  What is the right number of topics?  That's a matter of subjectivity, but when the topics appear to be duplicative, then you've modeled too many topics.  

Another way to look at the data is to identify terms that had the greatest difference in beta between topic 1 and topic 2. A good way to do this is with the log ratio of the two, $log_2(\beta_2 / \beta_1)$.  Log ratios are useful because the differences are symmetrical ($log_2(2) = 1$, and $log_2(.5) = -1$).  To constrain the analysis to a set of especially relevant words, filter for relatively common words having a beta greater than 1/1000 in at least one topic.
  
```{r}
ap_topics %>% 
  mutate(topic = paste0("topic", topic)) %>%
  pivot_wider(names_from = topic, values_from = beta) %>%
  filter(topic1 > 0.001 | topic2 > 0.001) %>%
  mutate(log_ratio = log2(topic2 / topic1)) %>%
  top_n(n = 20, w = abs(log_ratio)) %>%
  arrange(-log_ratio) %>%
  ggplot(aes(x = fct_rev(fct_inorder(term)), y = log_ratio)) +
  geom_col() +
  coord_flip()
```
  

Examine the per-document-per-topic probabilities, called gamma with the `matrix = "gamma"` argument to `tidy()`.

```{r}
(ap_documents <- tidy(ap_lda, matrix = "gamma"))
```

As an example, use topic modeling to see whether the chapters for four books cluster into the right books.

```{r}
library(gutenbergr)

books <- gutenberg_works(title %in% c("Twenty Thousand Leagues under the Sea", 
                                      "The War of the Worlds",
                                      "Pride and Prejudice", 
                                      "Great Expectations")) %>%
  gutenberg_download(meta_fields = "title")

by_chapter <- books %>%
  group_by(title) %>%
  mutate(chapter = cumsum(str_detect(text, regex("^chapter ", ignore_case = TRUE)))) %>%
  ungroup() %>%
  filter(chapter > 0) %>%
  unite(document, title, chapter)

by_chapter_word <- by_chapter %>%
  unnest_tokens(output = word, input = text, token = "words")

word_counts <- by_chapter_word %>%
  anti_join(stop_words) %>%
  count(document, word, sort = TRUE) %>%
  ungroup()

word_counts
```

The `topmodels` library requires `DocumentTermMatrix` objects, so cast `word_counts`.

```{r}
chapters_dtm <- word_counts %>%
  cast_dtm(document = document, term = word, value = n)

chapters_dtm
```

Create a four-topic model.

```{r}
chapters_lda <- LDA(chapters_dtm, k = 4, control = list(seed = 1234))
chapters_lda
```

What are the per-topic/word probabilities?

```{r}
chapter_topics <- tidy(chapters_lda, matrix = "beta")
chapter_topics
```

For each combination, the model computes the probability of that term being generated from that topic. The top 5 terms per topic are:

```{r}
top_terms <- chapter_topics %>%
  group_by(topic) %>%
  top_n(n = 5, wt = beta) %>%
  ungroup() %>%
  arrange(topic, -beta)

top_terms %>%
  ggplot(aes(x = reorder_within(term, beta, topic), y = beta, fill = factor(topic))) +
  geom_col(show.legend = FALSE) +
  facet_wrap(~ topic, scales = "free") +
  coord_flip() +
  scale_x_reordered()
```

These topics are pretty clearly associated with the four books!  Each "document" in this analysis was a single chapter. Which topics are associated with each document - can we put the chapters back together into the correct books? Examining the per-document-per-topic probabilities, (gamma).

Separate the document name into title and chapter, then visualize the per-document-per-topic probability for each. 

```{r}
chapters_gamma <- tidy(chapters_lda, matrix = "gamma") %>%
  separate(document, c("title", "chapter"), sep = "_", convert = TRUE)

chapters_gamma %>%
  mutate(title = reorder(title, gamma * topic)) %>%
  ggplot(aes(factor(topic), y = gamma)) + 
  geom_boxplot() +
  facet_wrap(~ title)

```

Almost all chapters from Pride and Prejudice, War of the Worlds, and Twenty Thousand Leagues Under the Sea were uniquely identified as a single topic each.  Some chapters from Great Expectations (topic 4) were somewhat associated with other topics. 

Are there any cases where the topic most associated with a chapter belonged to another book? First we’d find the topic that was most associated with each chapter using top_n(), which is effectively the “classification” of that chapter.  We can then compare each to the “consensus” topic for each book (the most common topic among its chapters), and see which were most often misidentified.

```{r}
chapter_classifications <- chapters_gamma %>%
  group_by(title, chapter) %>%
  top_n(1, gamma) %>%
  ungroup()

chapter_classifications

book_topics <- chapter_classifications %>%
  count(title, topic) %>%
  group_by(title) %>%
  top_n(1, n) %>%
  ungroup() %>%
  transmute(consensus = title, topic)

chapter_classifications %>%
  inner_join(book_topics, by = "topic") %>%
  filter(title != consensus)
```

Only two chapters from Great Expectations were misclassified.

The `augment()` function adds model output (token count and topic classification) to the original observations. 

```{r}
assignments <- augment(chapters_lda, data = chapters_dtm)
assignments
```

Combine with the book_topics summarization to assess the misclassifications.

```{r}
assignments <- assignments %>%
  separate(document, c("title", "chapter"), sep = "_", convert = TRUE) %>%
  inner_join(book_topics, by = c(".topic" = "topic"))
```

A good way to visualize the misclassifications is with a confusion matrix.

```{r}
library(scales)

assignments %>%
  count(title, consensus, wt = count) %>%
  group_by(title) %>%
  mutate(percent = n / sum(n)) %>%
  ggplot(aes(consensus, title, fill = percent)) +
  geom_tile() +
  scale_fill_gradient2(high = "red", label = percent_format()) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 90, hjust = 1),
        panel.grid = element_blank()) +
  labs(x = "Book words were assigned to",
       y = "Book words came from",
       fill = "% of assignments")
```

We notice that almost all the words for Pride and Prejudice, Twenty Thousand Leagues Under the Sea, and War of the Worlds were correctly assigned, while Great Expectations had a fair number of misassigned words (which, as we saw above, led to two chapters getting misclassified).  What were the most commmonly mistaken words?

```{r}
wrong_words <- assignments %>%
  filter(title != consensus)

wrong_words %>%
  count(title, consensus, term, wt = count) %>%
  ungroup() %>%
  arrange(desc(n))
```


# Appendix: String Manipulation

```{r}
library(stringr)
```


`print()` outputs strings as you might enter them, so embedded quotes are escaped.  Use `writeLines()` to see text as you might prefer to read them. `writeLines()` is similar to `cat()`, but does not attempt to convert non-character objects to strings.

Unicode is a standard for representing characters that might not be on your keyboard. Each available character has a Unicode code point: a number that uniquely identifies it. These code points are generally written in hex notation, that is, using base 16 and the digits 0-9 and A-F. You can find the code point for a particular character by looking up a [code chart](http://www.unicode.org/charts/).

Format numbers with `format`.  Here is how to format with comma-separations.  `digits` is *not* the number of decimal places; it's the number of significant digits

```{r}
x <- c(72.19, 1030.18, 102091.93, 1189192.18)
format(x, digits = 2, big.mark = ",", trim = TRUE, scientific = FALSE)
```

## stringr package

The **stringr** package is a simple wrapper around the more complete **stringi** package.  There are a ton of functions (see `help(package = "stringr")`), but here are some particularly useful ones.

* `str_c()` concatenates strings, similar to with `paste()` and `paste0()`.  
```{r}
str_c("hello", "world", sep = " ")
```

* `str_replace(string, pattern, replacment)` replaces `pattern` with `replacement`.  
```{r}
str_replace("If the future's looking bleek", pattern = fixed("bleek"), replacement = "dark")
```

* `str_replace_na(string, replacement)` replaces NAs.
```{r}
str_replace_na(c("We're the ones ", NA, "have to shine"), replacement = "who ")
```

* `str_split(string, pattern, simplify = FALSE)` splits `string` by `pattern` into a list of vectors, or matrix if `simplify = TRUE`. 
```{r}
str_split("If there's no one in control", pattern = " ", simplify = TRUE)
```

* `str_c(..., sep)` concatenates a vector of strings, separated by `sep`.
```{r}
str_c("we're", "the", "ones", "who", "draw", "the", "line", sep = " ")
```

`str_sub(string, start, end)` returns substring of `string` from `start` to `end`.  Use negatives to start from the end of the string.
```{r}
my_str <- "Although we live in trying times"
str_sub(my_str, start = 1, end = 5)
str_sub(my_str, start = -4, end = -1)
```

* `str_length(string)` returns the number of characters in a string.
```{r}
str_length("We're the ones who have to try")
```

* `str_detect(string, pattern)` returns booleans where `string` matches `pattern`.
```{r}
str_detect(c("Although we know", "that time",  "has wings"), pattern = fixed("wings"))
```

* `str_match(string, pattern)` returns matching strings where `string` matches `pattern`.
```{r}
str_match(c("Although we know", "that time",  "has wings"), pattern = "wings")
```

* `str_subset(string, pattern)` returns string matches where `string` matches `pattern`.
```{r}
str_subset(c("Although we know", "that time",  "has wings"), pattern = fixed("wings"))
```

* `str_count(string, pattern)` returns a count of matches where `string` matches `pattern`.
```{r}
str_count(c("Although we know", "that time",  "has wings"), pattern = fixed("wings"))
```

* `str_extract(string, pattern)` returns the part of the `string` matching `pattern`.
```{r}
str_extract(c("We're the ones", "who have to fly"), pattern = " t..")
```

## Regular Expressions
The **rebus** package is a good resource for building regular expressions.

```{r}
library(rebus)
```

The `%R%` operator concatenates the regular expression.  `START` represents regex "^" meaning "starting with".  `END` represents regex "$" meaning "ending with".
```{r}
x <- austen_books() %>% 
  filter(book == "Sense & Sensibility") %>%
  select(text) %>%
  head(100) %>%
  pull()
```

Here are lines from Sense & Sensibility that start with "Mr".
```{r}
str_subset(x, pattern = START %R% "Mr")
```

`ANY_CHAR` represents regex "."  Here are lines from Sense & Sensibility with pattern "*handsome*"
```{r}
str_subset(x, pattern = ANY_CHAR %R% "handsome" %R% ANY_CHAR)
```

`char_class()` is similar to `ANY_CHAR` except that it matches any character from the string parameter.  It is the same as regex "[]".  The opposite is `negated_char_class()`, which is the same as "[^]".  `char_class()` can accept ranges, such as "0-9", and "a-z".  `DGT` is the same thing as "0-9".  
```{r}
str_subset(c("apple", "Aardvark", "Orukidn"), char_class("Aa"))
```


`DOT`, `CARAT`, and `DOLLAR` represent special characters, "\.", "\%", and "\$".  Function `or()` provides alteration.

```{r}
str_match(c("kittycat", "doggone"), pattern = or("dog", "cat"))
```

Look for repeating patterns with `optional()`, `zero_or_more()`, `one_or_more()`, and `repeated()`.

Wrap a rebus expression in `capture()` to create a column in the output for the match to each captured part of the regex.
```{r}
phone_string <- c("555-123-4567", 
                  "(555)123-4567", 
                  "555.123.4567", 
                  "555-123-4567 (M), 555-123-7654 (H)")
phone_pattern <- 
  capture(DGT %R% DGT %R% DGT) %R% zero_or_more(char_class("()-.")) %R% 
  capture(DGT %R% DGT %R% DGT) %R% zero_or_more(char_class("()-.")) %R%
  capture(DGT %R% DGT %R% DGT %R% DGT)

# first match with str_match()
phone_match <- str_match(phone_string, pattern = phone_pattern)
str_c("(", phone_match[, 2], ")", phone_match[, 3], "-", phone_match[, 4])

# all matches with str_match_all() and lapply()
phone_match_all <- str_match_all(phone_string, pattern = phone_pattern)
lapply(phone_match_all, function(x){str_c("(", x[, 2], ")", x[, 3], "-", x[, 4])}) %>% unlist()
```

You can refer to captured patterns with `REF[0-9]`.
```{r}
str_match(c("hello", "sweet", "kitten"), 
  pattern = capture(LOWER) %R% REF1)
```

Here is an exercise working with the Oscal Wilde play "The Importance of Being Earnest".

```{r}
earnest <- read_lines("http://s3.amazonaws.com/assets.datacamp.com/production/course_2922/datasets/importance-of-being-earnest.txt")
```

The text is between the lines with "START OF THE PROJECT" and "END OF THE PROJECT".  `str_which()` returns the indices where the string contains the pattern. The text consists of an introduction and the play itself.  The play starts at "FIRST ACT".
```{r}
start <- str_which(earnest, fixed("START OF THE PROJECT"))
end <- str_which(earnest, fixed("END OF THE PROJECT"))
earnest_sub <- earnest[(start+1):(end-1)]

play_start <- str_which(earnest_sub, "FIRST ACT")
intro_line_index <- 1:(play_start - 1)
intro_text <- earnest_sub[intro_line_index]
play_text <- earnest_sub[-intro_line_index]

# remove the emptly lines
play_lines <- play_text[str_length(play_text) > 0] %>% as.character()

# print first 20 lines
writeLines(play_lines[1:20])
```

How would you identify lines where the character is starting to speak?  You might look for a capitalized word followed by a ".".
```{r}
pattern <- START %R% ascii_upper() %R% one_or_more(WRD) %R% DOT

lines <- str_subset(play_lines, pattern)

# Extract the matching string (the character speaking)
who <- str_extract(lines, pattern)

# Let's see what we have
unique(who)
```

Close, but not perfect.  If you know the characters, just search for them directly.  `or1()` is like `or()` but lets you supply a vector of strings.
```{r}
characters <- c("Algernon", "Jack", "Lane", "Cecily", "Gwendolen", "Chasuble", 
  "Merriman", "Lady Bracknell", "Miss Prism")

pattern <- START %R% or1(characters) %R% DOT

lines <- str_subset(play_lines, pattern)

# Extract the matching string (the character speaking)
who <- str_extract(lines, pattern)

# Let's see what we have
unique(who)

# Lines per character 
table(who)
```


# Reference

Silge, J., & Robinson, D. (2019). Text Mining with R. O'Reilly Media. https://www.tidytextmining.com.
https://juliasilge.com/blog/evaluating-stm/

Dotson, Marc.  "Introduction to Text Analysis in R". DataCamp. https://www.datacamp.com/courses/introduction-to-text-analysis-in-r., 

String Manipulation in R with stringr,
Text Mining: Bag of Words, 
Sentiment Analysis in R.

Other DataCamp Courses
Sentiment Analysis in R: The Tidy Way, 
Topic Modeling in R,
Introduction to Natural Language Processing in R.  

There are also some projects in DataCamp, and tutorial.


