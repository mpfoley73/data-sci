[
["support-vector-machines.html", "Chapter 9 Support Vector Machines", " Chapter 9 Support Vector Machines These notes rely on (James et al. 2013), (Hastie, Tibshirani, and Friedman 2017), and (Kuhn and Johnson 2016). I also reviewed the material in PSU’s Applied Data Mining and Statistical Learning (STAT 508), and the e1071 Support Vector Machines vignette. The Support Vector Machines (SVM) algorithm finds the optimal separating hyperplane between members of two classes using an appropriate nonlinear mapping to a sufficiently high dimension. The hyperplane is defined by the observations that lie within a margin optimized by a cost hyperparameter. These observations are called the support vectors. SVM is an extension of the support vector classifier which in turn is a generalization of the simple and intuitive maximal margin classifier. References "],
["maximal-margin-classifier.html", "9.1 Maximal Margin Classifier", " 9.1 Maximal Margin Classifier The maximal margin classifier is the optimal hyperplane defined in the (rare) case where two classes are linearly separable. Given an \\(n \\times p\\) data matrix \\(X\\) with binary response variable defined as \\(y \\in [-1, 1]\\) it may be possible to define a p-dimensional hyperplane \\(h(X) = \\beta_0 + \\beta_1X_1 + \\beta_2X_2 \\dots + \\beta_pX_p = x_i^T \\beta + \\beta_0 = 0\\) such that all observations of each class fall on opposite sides of the hyperplane. This “separating hyperplane” has the property that if \\(\\beta\\) is constrained to be a unit vector, \\(||\\beta|| = \\sum\\beta^2 = 1\\), then the product of the hyperplane and response variables are positive perpendicular distances from the hyperplane, the smallest of which may be termed the hyperplane margin, \\(M\\), \\[y_i (x_i^{&#39;} \\beta + \\beta_0) \\ge M.\\] The maximal margin classifier is the hyperplane with the maximum margin. That is, \\(\\max \\{M\\}\\) subject to \\(||\\beta|| = 1\\). A separating hyperplane rarely exists. In fact, even if a separating hyperplane does exist, its resulting margin is probably undesirably narrow. "],
["support-vector-classifier.html", "9.2 Support Vector Classifier", " 9.2 Support Vector Classifier The maximal margin classifier can be generalized to non-separable cases using a so-called “soft margin”. The generalization is called the support vector classifier. The soft margin allows some misclassification in the interest of greater robustness to individual observations. The support vector classifier optimizes \\[y_i (x_i^{&#39;} \\beta + \\beta_0) \\ge M(1 - \\xi_i)\\] where the \\(\\xi_i\\) are positive slack variables whose sum is bounded by some constant tuning parameter \\(\\sum{\\xi_i} \\le constant\\). The slack variable values indicate where the observation lies: \\(\\xi_i = 0\\) observations lie on the correct side of the margin; \\(\\xi_i &gt; 0\\) observation lie on the wrong side of the margin; \\(\\xi_i &gt; 1\\) observations lie on the wrong side of the hyperplane. The constant sets the tolerance for margin violation. If \\(constant = 0\\), then all observations must reside on the correct side of the margin, as in the maximal margin classifier. The \\(constant\\) controls the bias-variance trade-off. As the \\(constant\\) increases, the margin widens and allows more violations. The classifier bias increases but its variance decreases. The support vector classifier is usually defined by dropping the \\(||\\beta|| = 1\\) constraint, and defining \\(M = 1 / ||\\beta||\\). The optimization problem then becomes \\[ \\min ||\\beta|| \\hspace{2mm} s.t. \\hspace{2mm} \\begin{cases} y_i(x_i^T\\beta + \\beta_0) \\ge 1 - \\xi_i, \\hspace{2mm} \\forall i &amp; \\\\ \\xi_i \\ge 0, \\hspace{2mm} \\sum \\xi_i \\le constant. \\end{cases} \\] This is a quadratic equation with linear inequality constraints, so it is a convex optimization problem which can be solved using Lagrange multipliers. Re-express the optimization problem as \\[ \\min_{\\beta_0, \\beta} \\frac{1}{2}||\\beta||^2 = C\\sum_{i = 1}^N \\xi_i \\\\ s.t. \\xi_i \\ge 0, \\hspace{2mm} y_i(x_i^T\\beta + \\beta_0) \\ge 1 - \\xi_i, \\hspace{2mm} \\forall i \\] where the “cost” parameter \\(C\\) replaces the constant and penalizes large residuals. This optimization problem is equivalent to another optimization problem, the familiar loss + penalty formulation: \\[\\min_{\\beta_0, \\beta} \\sum_{i=1}^N{[1 - y_if(x_i)]_+} + \\frac{\\lambda}{2} ||\\beta||^2 \\] where \\(\\lambda = 1 / C\\) and \\([1 - y_if(x_i)]_+\\) is a “hinge” loss function with \\(f(x_i) = sign[Pr(Y = +1|x) - 1 / 2]\\). The parameter estimates can be written as functions of a set of unknown parameters \\((\\alpha_i)\\) and data points. The solution to the optimization problem requires only the inner products of the observations, represented as \\(\\langle x_i, x_j \\rangle\\), \\[f(x) = \\beta_0 + \\sum_{i = 1}^n {\\alpha_i \\langle x, x_i \\rangle}\\] The solution has the interesting property that only observations on or within the margin affect the hyperplane. These observations are known as support vectors. As the constant increases, the number of violating observations increase, and thus the number of support vectors increases. This property makes the algorithm robust to the extreme observations far away from the hyperplane. The parameter estimators for \\(\\alpha_i\\) are nonzero only for the support vectors in the solution—that is, if a training observation is not a support vector, then its \\(\\alpha_i\\) equals zero. The only shortcoming with the algorithm is that it presumes a linear decision boundary. "],
["support-vector-machines-1.html", "9.3 Support Vector Machines", " 9.3 Support Vector Machines Enlarging the feature space of the support vector classifier accommodates nonlinar relationships. Support vector machines do this in a specific way, using kernals. The kernal is a generalization of the inner product with form \\(K(x_i, x_i^{&#39;})\\). So the linear kernal is simply \\[K(x_i, x_i^{&#39;}) = \\langle x, x_i \\rangle\\] and the solution is \\[f(x) = \\beta_0 + \\sum_{i = 1}^n {\\alpha_i K(x_i, x_i^{&#39;})}\\] \\(K\\) can take onother form instead, such as polynomial \\[K(x, x&#39;) = (\\gamma \\langle x, x&#39; \\rangle + c_0)^d\\] or radial \\[K(x, x&#39;) = \\exp\\{-\\gamma ||x - x&#39;||^2\\}.\\] "],
["example-6.html", "9.4 Example", " 9.4 Example Here is a data set of two classes \\(y \\in [-1, 1]\\) described by two features \\(X1\\) and \\(X2\\). library(tidyverse) set.seed(1) x &lt;- matrix(rnorm (20*2), ncol=2) y &lt;- c(rep(-1, 10), rep(1, 10)) x[y==1, ] &lt;- x[y==1, ] + 1 train_data &lt;- data.frame(x, y) train_data$y &lt;- as.factor(y) A scatter plot reveals whether the classes are linearly separable. ggplot(train_data, aes(x = X1, y = X2, color = y)) + geom_point(size = 2) + labs(title = &quot;Binary response with two features&quot;) + theme(legend.position = &quot;top&quot;) No, they are not linearly separable. Now fit a support vector machine. The e1071 library implements the SVM algorithm. svm(..., kernel=\"linear\") fits a support vector classifier. Change the kernal to c(\"polynomial\", \"radial\") for SVM. Try a cost of 10. library(e1071) ## Warning: package &#39;e1071&#39; was built under R version 3.6.2 m &lt;- svm( y ~ ., data = train_data, kernel = &quot;linear&quot;, type = &quot;C-classification&quot;, # (default) for classification cost = 10, # default is 1 scale = FALSE # do not standardize features ) plot(m, train_data) The support vectors are plotted as “x’s”. There are seven of them. m$index ## [1] 1 2 5 7 14 16 17 The summary shows adds additional information, including the distribution of the support vector classes. summary(m) ## ## Call: ## svm(formula = y ~ ., data = train_data, kernel = &quot;linear&quot;, type = &quot;C-classification&quot;, ## cost = 10, scale = FALSE) ## ## ## Parameters: ## SVM-Type: C-classification ## SVM-Kernel: linear ## cost: 10 ## ## Number of Support Vectors: 7 ## ## ( 4 3 ) ## ## ## Number of Classes: 2 ## ## Levels: ## -1 1 The seven support vectors are comprised of four in one class, three in the other. What if we lower the cost of margin violations? This will increase bias and lower variance. m &lt;- svm( y ~ ., data = train_data, kernel = &quot;linear&quot;, type = &quot;C-classification&quot;, cost = 0.1, scale = FALSE ) plot(m, train_data) There are many more support vectors now. (In case you hoped to see the linear decision boundary formulation, or at least a graphical representation of the margins, keep hoping. The model is generalized beyond two features, so it evidently does not worry too much about supporting sanitized two-feature demos.) Which cost level yields the best predictive performance on holdout data? Use cross validation to find out. SVM defaults to 10-fold CV. I’ll try seven candidate values for cost. set.seed(1) m_tune &lt;- tune( svm, y ~ ., data = train_data, kernel =&quot;linear&quot;, ranges = list(cost = c(0.001, 0.01, 0.1, 1, 5, 10, 100)) ) summary(m_tune) ## ## Parameter tuning of &#39;svm&#39;: ## ## - sampling method: 10-fold cross validation ## ## - best parameters: ## cost ## 0.1 ## ## - best performance: 0.05 ## ## - Detailed performance results: ## cost error dispersion ## 1 1e-03 0.55 0.4377975 ## 2 1e-02 0.55 0.4377975 ## 3 1e-01 0.05 0.1581139 ## 4 1e+00 0.15 0.2415229 ## 5 5e+00 0.15 0.2415229 ## 6 1e+01 0.15 0.2415229 ## 7 1e+02 0.15 0.2415229 The lowest cross-validation error rate is 0.10 with cost = 0.1. tune() saves the best tuning parameter value. m_best &lt;- m_tune$best.model summary(m_best) ## ## Call: ## best.tune(method = svm, train.x = y ~ ., data = train_data, ranges = list(cost = c(0.001, ## 0.01, 0.1, 1, 5, 10, 100)), kernel = &quot;linear&quot;) ## ## ## Parameters: ## SVM-Type: C-classification ## SVM-Kernel: linear ## cost: 0.1 ## ## Number of Support Vectors: 16 ## ## ( 8 8 ) ## ## ## Number of Classes: 2 ## ## Levels: ## -1 1 There are 16 support vectors, 8 in each class. This is a pretty wide margin. plot(m_best, train_data) What if the classes had been linearly separable? Then we could create a maximal margin classifier. train_data_2 &lt;- train_data %&gt;% mutate( X1 = X1 + ifelse(y==1, 1.0, 0), X2 = X2 + ifelse(y==1, 1.0, 0) ) ggplot(train_data_2, aes(x = X1, y = X2, color = y)) + geom_point(size = 2) + labs(title = &quot;Binary response with two features, linearly separable&quot;) Specify a huge cost = 1e5 so that no support vectors violate the margin. m2 &lt;- svm( y ~ ., data = train_data_2, kernel = &quot;linear&quot;, cost = 1e5, scale = FALSE # do not standardize features ) plot(m2, train_data_2) summary(m2) ## ## Call: ## svm(formula = y ~ ., data = train_data_2, kernel = &quot;linear&quot;, cost = 1e+05, ## scale = FALSE) ## ## ## Parameters: ## SVM-Type: C-classification ## SVM-Kernel: linear ## cost: 1e+05 ## ## Number of Support Vectors: 3 ## ## ( 1 2 ) ## ## ## Number of Classes: 2 ## ## Levels: ## -1 1 This model will have very low bias, but very high variance. To fit an SVM, use a different kernel. You can use kernal = c(\"polynomial\", \"radial\", \"sigmoid\"). For a polynomial model, also specify the polynomial degree. For a radial model, include the gamma value. set.seed(1) m3_tune &lt;- tune( svm, y ~ ., data = train_data, kernel =&quot;polynomial&quot;, ranges = list( cost = c(0.001, 0.01, 0.1, 1, 5, 10, 100), degree = c(1, 2, 3) ) ) summary(m3_tune) ## ## Parameter tuning of &#39;svm&#39;: ## ## - sampling method: 10-fold cross validation ## ## - best parameters: ## cost degree ## 1 1 ## ## - best performance: 0.1 ## ## - Detailed performance results: ## cost degree error dispersion ## 1 1e-03 1 0.55 0.4377975 ## 2 1e-02 1 0.55 0.4377975 ## 3 1e-01 1 0.30 0.2581989 ## 4 1e+00 1 0.10 0.2108185 ## 5 5e+00 1 0.10 0.2108185 ## 6 1e+01 1 0.15 0.2415229 ## 7 1e+02 1 0.15 0.2415229 ## 8 1e-03 2 0.70 0.4216370 ## 9 1e-02 2 0.70 0.4216370 ## 10 1e-01 2 0.70 0.4216370 ## 11 1e+00 2 0.65 0.2415229 ## 12 5e+00 2 0.50 0.3333333 ## 13 1e+01 2 0.50 0.3333333 ## 14 1e+02 2 0.50 0.3333333 ## 15 1e-03 3 0.65 0.3374743 ## 16 1e-02 3 0.65 0.3374743 ## 17 1e-01 3 0.50 0.3333333 ## 18 1e+00 3 0.40 0.3162278 ## 19 5e+00 3 0.35 0.3374743 ## 20 1e+01 3 0.35 0.3374743 ## 21 1e+02 3 0.35 0.3374743 The lowest cross-validation error rate is 0.10 with cost = 1, polynomial degree 1. m3_best &lt;- m3_tune$best.model summary(m3_best) ## ## Call: ## best.tune(method = svm, train.x = y ~ ., data = train_data, ranges = list(cost = c(0.001, ## 0.01, 0.1, 1, 5, 10, 100), degree = c(1, 2, 3)), kernel = &quot;polynomial&quot;) ## ## ## Parameters: ## SVM-Type: C-classification ## SVM-Kernel: polynomial ## cost: 1 ## degree: 1 ## coef.0: 0 ## ## Number of Support Vectors: 12 ## ## ( 6 6 ) ## ## ## Number of Classes: 2 ## ## Levels: ## -1 1 There are 12 support vectors, 6 in each class. This is a pretty wide margin. plot(m3_best, train_data) "],
["using-caret.html", "9.5 Using Caret", " 9.5 Using Caret The model can also be fit using caret. I’ll used LOOCV since the data set is so small. Normalize the variables to make their scale comparable. library(caret) library(kernlab) train_data_3 &lt;- train_data %&gt;% mutate(y = factor(y, labels = c(&quot;A&quot;, &quot;B&quot;))) m4 &lt;- train( y ~ ., data = train_data_3, method = &quot;svmPoly&quot;, preProcess = c(&quot;center&quot;, &quot;scale&quot;), trControl = trainControl( method = &quot;cv&quot;, number = 5, summaryFunction = twoClassSummary, # Use AUC to pick the best model classProbs=TRUE ) ) m4$bestTune ## degree scale C ## 8 1 0.1 0.5 plot(m4) "]
]
