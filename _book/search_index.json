[["index.html", "My Data Science Notes Intro", " My Data Science Notes Michael Foley 2023-11-30 Intro These notes are pulled from various classes, tutorials, books, etc. and are intended for my own consumption. If you are finding this on the internet, I hope it is useful to you, but you should know that I am just a student and there’s a good chance whatever you’re reading here is mistaken. "],["topic-modeling.html", "Chapter 1 Topic Modeling", " Chapter 1 Topic Modeling It’s a good idea to explore the data before modeling. One good way to do that is with the TF-IDF statistic. A term’s frequency (TF) is its proportion of the words in the document. The inverse document frequency (IDF) is the log of the inverse ratio of documents in which the term appears. The product of TF and IDF (TF-IDF) indicates how important a word is to a document in a corpus. In our hotel review case study, the TF-IDF indicates how important a word is to the review. A term’s TF-IDF increases with its frequency in the document (review) and decreases with the number of documents (reviews) in the corpus that contain it. Use tidytext::bind_tf_idf() to append the tf, idf, and tf_idf columns to your data frame. sawywer_tf_idf &lt;- sawyer_tokens %&gt;% count(chapter, word_stem, sort = TRUE) %&gt;% bind_tf_idf(word_stem, chapter, n) %&gt;% group_by(chapter) %&gt;% slice_max(order_by = tf_idf, n = 10) %&gt;% ungroup() sawywer_tf_idf %&gt;% filter(chapter &lt;= 6) %&gt;% mutate(word_stem = reorder_within(word_stem, by = tf_idf, within = chapter)) %&gt;% ggplot(aes(word_stem, tf_idf, fill = as.factor(chapter))) + geom_col(alpha = 0.8, show.legend = FALSE) + scale_fill_manual(values = RColorBrewer::brewer.pal(n = 6, name = &quot;Set2&quot;), name = &quot;Topic&quot;) + facet_wrap(~ chapter, scales = &quot;free&quot;, ncol = 3) + scale_x_reordered() + coord_flip() + theme(strip.text=element_text(size=11)) + labs(x = NULL, y = &quot;tf-idf&quot;, title = &quot;Highest tf-idf words in The Adventures of Tom Sawyer (ch 1-6)&quot;, subtitle = &quot;Individual chapters focus on different characters and narrative elements&quot;) 1.0.1 LDA LDA treats each document as a mixture of topics (X% topic A, Y% topic B, etc.), and each topic as a mixture of word probabilities (x% word a, y% word b, etc.) for all words in the corpus. LDA is implemented in the topicmodels package. Prepare the data by creating a document-term matrix. You will improve performance by removing infrequently appearing tokens with tm::removeSparseTemrs(). sawyer_dtm &lt;- sawyer_tokens %&gt;% count(chapter, word_stem) %&gt;% cast_dtm(document = chapter, term = word_stem, value = n) %&gt;% tm::removeSparseTerms(sparse = 0.9) sawyer_dtm LDA is an optimization algorithm that performs a random search through the parameter space to find the model with the largest log-likelihood. There are multiple search algorithms, but the preferred one appears to be Gibbs sampling, a type of Monte Carlo Markov Chain (MCMC) algorithm. Create a topic model with topicmodels::LDA(). Parameter k specifies the number of topics. In general, you only want as many topics as are clearly distinct and that you can easily communicate to others. You can use the perplexity statistic to help identify k. Perplexity is a measure of how well a probability model fits a new set of data. Look for the elbow in a scree plot. Here are models with 5 - 50 topics. set.seed(1012) train_ind &lt;- sample(nrow(sawyer_dtm), floor(0.75*nrow(sawyer_dtm))) sawyer_train &lt;- sawyer_dtm[train_ind, ] sawyer_test &lt;- sawyer_dtm[-train_ind, ] k = c(seq(from = 5, to = 50, by = 5)) perp &lt;- k %&gt;% map(~ LDA(sawyer_train, k = .x, method = &quot;Gibbs&quot;, control = list(seed = 1234))) %&gt;% map(~ perplexity(.x, newdata = sawyer_test)) %&gt;% as.numeric() data.frame(k = k, perplexity = perp) %&gt;% ggplot(aes(x = k, y = perplexity)) + geom_point() + geom_smooth(method = &quot;loess&quot;, se = FALSE) + labs(title = &quot;Perplexity Plot for LDM model&quot;, subtitle = &quot;Elbow at k = 30?&quot;) There may be an elbow at k = 15 topics. Using STM, the optimal number of clusters was 30. That looks like an elbow to me too. Frankly, if my arm looked like that I would consult an orthopedic surgeon. sawyer_lda &lt;- topicmodels::LDA(sawyer_dtm, k = 30, method = &quot;Gibbs&quot;, control = list(seed = 1234)) LDA() returns two outputs: a “beta” matrix of probabilities of terms belonging to topics; a “gamma” matrix of probabilities of topics contributing to documents. The tidytext package provides a tidy() method for extracting these matrices. sawyer_lda_beta &lt;- tidy(sawyer_lda, matrix = &quot;beta&quot;) sawyer_lda_gamma &lt;- tidy(sawyer_lda, matrix = &quot;gamma&quot;, document_names = rownames(sawyer_dfm)) # All sums equal 1 # sawyer_lda_beta %&gt;% group_by(topic) %&gt;% summarize(.groups = &quot;drop&quot;, sum_beta = sum(beta)) # sawyer_lda_gamma %&gt;% group_by(document) %&gt;% summarize(.groups = &quot;drop&quot;, sum_beta = sum(gamma)) I have 30 topics here, so it would be hard to show the top words per topic, but here are the first six topics. sawyer_lda_beta %&gt;% filter(topic &lt;= 6) %&gt;% group_by(topic) %&gt;% slice_max(order_by = beta, n = 10, with_ties = FALSE) %&gt;% mutate(term = reorder_within(term, beta, topic)) %&gt;% ggplot(aes(x = term, y = beta, fill = factor(topic))) + geom_col(show.legend = FALSE) + scale_fill_manual(values = RColorBrewer::brewer.pal(n = 6, name = &quot;Set2&quot;), name = &quot;Topic&quot;) + scale_x_reordered() + coord_flip() + facet_wrap(~ topic, scales = &quot;free&quot;) + labs(title = &quot;LDA Beta Matrix for first six topics&quot;, subtitle = &quot;Showing top 10 word probabilities&quot;) You can use a Word cloud as an alternative to the bar chart. The advantage of the word cloud is that it creates an instantaneous impression rather than providing you the analytic means to construct the same conclusion. Here are word clouds for the first two topics. colors6 &lt;- RColorBrewer::brewer.pal(n = 6, name = &quot;Set2&quot;) x &lt;- map(c(1:2), ~ with(sawyer_lda_beta %&gt;% filter(topic == .x), wordcloud::wordcloud(term, beta, max.words = 20, colors = colors6[.x]))) And here are the most prevalent topics across chapters. The figure shows the average probability that the topic appears in the chapter for all chapters. top_terms &lt;- sawyer_lda_beta %&gt;% group_by(topic) %&gt;% slice_max(order_by = beta, n = 7) %&gt;% summarise(.groups = &quot;drop&quot;, terms = list(term)) %&gt;% mutate(terms = map(terms, paste, collapse = &quot;, &quot;)) %&gt;% unnest(terms) sawyer_lda_gamma %&gt;% group_by(topic) %&gt;% summarize(.groups = &quot;drop&quot;, gamma = mean(gamma)) %&gt;% left_join(top_terms, by = &quot;topic&quot;) %&gt;% mutate(topic = paste(&quot;topic&quot;, topic), topic = fct_reorder(topic, gamma)) %&gt;% slice_max(order_by = gamma, n = 10) %&gt;% ggplot(aes(x = topic, y = gamma, label = terms)) + geom_col(fill = &quot;#D8A7B1&quot;, show.legend = FALSE) + geom_text(hjust = 0, nudge_y = 0.0005, size = 3) + coord_flip() + scale_y_continuous(expand = c(0,0), limits = c(0, 0.09), labels = scales::percent_format()) + theme_minimal() + theme(panel.grid = element_blank()) + labs(x = NULL, y = expression(gamma), title = &quot;Top 10 LDA topics by prevalence in The Adentures of Tom Sawyer&quot;, subtitle = &quot;With top words in each topic&quot;) Another way to look at the betas is to identify terms that had the greatest difference in beta between the first and second most probable topic. A good way to do this is with their log ratio, \\(log_2(\\beta_2 / \\beta_1)\\). Filter for relatively common words having a beta greater than 1/100 in at least one topic. sawyer_lda_beta %&gt;% mutate(topic = paste0(&quot;topic&quot;, topic)) %&gt;% group_by(term) %&gt;% slice_max(order_by = beta, n = 2) %&gt;% summarize(.groups = &quot;drop&quot;, min_beta = min(beta), max_beta = max(beta)) %&gt;% filter(max_beta &gt; 0.01) %&gt;% mutate(log_ratio = log2(max_beta / min_beta)) %&gt;% top_n(n = 20, w = abs(log_ratio)) %&gt;% arrange(-log_ratio) %&gt;% ggplot(aes(x = fct_rev(fct_inorder(term)), y = log_ratio)) + geom_col(fill = &quot;#D8A7B1&quot;) + theme_minimal() + coord_flip() + labs(title = &quot;LDA beta matrix log ratios&quot;, subtitle = &quot;showing greatest differences in beta values&quot;, x = &quot;&quot;, y = &quot;log(beta ratio)&quot;) 1.0.2 STM Prepare the data by creating a document-term matrix, just as you would with LDA, except this time use the cast_dfm() to create a document feature matrix for the quanteda package (the stm package uses quanteda). As LDA, you will improve performance by removing infrequently appearing tokens, this time with tm::removeSparseTemrs(). sawyer_dfm &lt;- sawyer_tokens %&gt;% count(chapter, word_stem) %&gt;% cast_dfm(document = chapter, term = word_stem, value = n) %&gt;% quanteda::dfm_trim(min_docfreq = 0.1, docfreq_type = &quot;prop&quot;) sawyer_dfm Create a topic model with stm::stm(). Parameter K specifies the number of topics. In LDA I used perplexity to determine the optimal number of clusters, in part because that is the only optimizing metric it LDA() offers. stm offers other metrics, including the held-out likelihood and coherence. Here are models with 5 - 50 topics. This process can take a while, but the furrr package and future_map() function leverage parallel processing to make it quicker. library(furrr) plan(multiprocess) sawyer_stm_mdls &lt;- data_frame(K = seq(from = 5, to = 50, by = 5)) %&gt;% mutate(mdl = future_map(K, ~stm(sawyer_dfm, K = ., verbose = FALSE), .options = furrr_options(seed = 123))) heldout &lt;- make.heldout(sawyer_dfm) k_result &lt;- sawyer_stm_mdls %&gt;% mutate(exclusivity = map(mdl, exclusivity), semantic_coherence = map(mdl, semanticCoherence, sawyer_dfm), eval_heldout = map(mdl, eval.heldout, heldout$missing), residual = map(mdl, checkResiduals, sawyer_dfm), bound = map_dbl(mdl, ~max(.$convergence$bound)), lfact = map_dbl(mdl, ~lfactorial(.$settings$dim$K)), lbound = bound + lfact, iterations = map_dbl(mdl, ~length(.$convergence$bound))) k_result %&gt;% transmute(K, `Lower bound` = lbound, Residuals = map_dbl(residual, &quot;dispersion&quot;), `Semantic coherence` = map_dbl(semantic_coherence, mean), `Held-out likelihood` = map_dbl(eval_heldout, &quot;expected.heldout&quot;)) %&gt;% gather(Metric, Value, -K) %&gt;% ggplot(aes(K, Value, color = Metric)) + geom_line(size = 1.5, alpha = 0.7, show.legend = FALSE) + facet_wrap(~Metric, scales = &quot;free_y&quot;) + labs(x = &quot;K (number of topics)&quot;, y = NULL, title = &quot;Model diagnostics by number of topics&quot;, subtitle = &quot;These diagnostics indicate that a good number of topics would be around 60&quot;) The held-out likelihood is highest between 30 and 50, and the residuals are lowest at 20, so 30 might be the right number. Semantic coherence is maximized when the most probable words in a given topic frequently co-occur together. Coherence tends to fall as exclusivity increases. You’ll want the topic size that balances the trade-off. k_result %&gt;% select(K, exclusivity, semantic_coherence) %&gt;% filter(K %in% c(20, 25, 30)) %&gt;% unnest(cols = c(exclusivity, semantic_coherence)) %&gt;% mutate(K = as.factor(K)) %&gt;% ggplot(aes(semantic_coherence, exclusivity, color = K)) + geom_point(size = 2, alpha = 0.7) + labs(x = &quot;Semantic coherence&quot;, y = &quot;Exclusivity&quot;, title = &quot;Comparing exclusivity and semantic coherence&quot;, subtitle = &quot;Models with fewer topics have higher semantic coherence for more topics, but lower exclusivity&quot;) It looks like k = 30 may be optimal. sawyer_stm &lt;- sawyer_stm_mdls %&gt;% filter(K == 30) %&gt;% pull(mdl) %&gt;% pluck(1) Like LDA(), stm() returns two outputs: a “beta” matrix of probabilities of terms belonging to topics; a “gamma” matrix of probabilities of topics contributing to documents. The tidytext package provides a tidy() method for extracting these matrices. sawyer_stm_beta &lt;- tidy(sawyer_stm, matrix = &quot;beta&quot;) sawyer_stm_gamma &lt;- tidy(sawyer_stm, matrix = &quot;gamma&quot;, document_names = rownames(sawyer_dfm)) I have 30 topics here, so it would be hard to show the top words per topic, but here are the first six topics. sawyer_stm_beta %&gt;% filter(topic &lt;= 6) %&gt;% group_by(topic) %&gt;% slice_max(order_by = beta, n = 10, with_ties = FALSE) %&gt;% mutate(term = reorder_within(term, beta, topic)) %&gt;% ggplot(aes(x = term, y = beta, fill = factor(topic))) + geom_col(show.legend = FALSE) + scale_fill_manual(values = RColorBrewer::brewer.pal(n = 6, name = &quot;Set2&quot;), name = &quot;Topic&quot;) + scale_x_reordered() + coord_flip() + facet_wrap(~ topic, scales = &quot;free&quot;) + labs(title = &quot;STM Beta Matrix for first six topics&quot;, subtitle = &quot;Showing top 10 word probabilities&quot;) Here is a Word cloud representation. colors6 &lt;- RColorBrewer::brewer.pal(n = 6, name = &quot;Set2&quot;) x &lt;- map(c(1:2), ~ with(sawyer_stm_beta %&gt;% filter(topic == .x), wordcloud::wordcloud(term, beta, max.words = 20, colors = colors6[.x]))) And here are the most prevalent topics across chapters. top_terms &lt;- sawyer_stm_beta %&gt;% group_by(topic) %&gt;% slice_max(order_by = beta, n = 7) %&gt;% summarise(.groups = &quot;drop&quot;, terms = list(term)) %&gt;% mutate(terms = map(terms, paste, collapse = &quot;, &quot;)) %&gt;% unnest(terms) sawyer_stm_gamma %&gt;% group_by(topic) %&gt;% summarize(.groups = &quot;drop&quot;, gamma = mean(gamma)) %&gt;% left_join(top_terms, by = &quot;topic&quot;) %&gt;% mutate(topic = paste(&quot;topic&quot;, topic), topic = fct_reorder(topic, gamma)) %&gt;% slice_max(order_by = gamma, n = 10) %&gt;% ggplot(aes(x = topic, y = gamma, label = terms)) + geom_col(fill = &quot;#D8A7B1&quot;, show.legend = FALSE) + geom_text(hjust = 0, nudge_y = 0.0005, size = 3) + coord_flip() + scale_y_continuous(expand = c(0,0), limits = c(0, 0.09), labels = scales::percent_format()) + theme_minimal() + theme(panel.grid = element_blank()) + labs(x = NULL, y = expression(gamma), title = &quot;Top 10 STM topics by prevalence in The Adentures of Tom Sawyer&quot;, subtitle = &quot;With top words in each topic&quot;) Another way to look at the betas is to identify terms that had the greatest difference in beta between the first and second most probable topic. A good way to do this is with their log ratio, \\(log_2(\\beta_2 / \\beta_1)\\). Filter for relatively common words having a beta greater than 1/100 in at least one topic. sawyer_stm_beta %&gt;% mutate(topic = paste0(&quot;topic&quot;, topic)) %&gt;% group_by(term) %&gt;% slice_max(order_by = beta, n = 2) %&gt;% summarize(.groups = &quot;drop&quot;, min_beta = min(beta)+.001, max_beta = max(beta)+.001) %&gt;% filter(max_beta &gt; 0.01) %&gt;% mutate(log_ratio = log2(max_beta / min_beta)) %&gt;% top_n(n = 20, w = abs(log_ratio)) %&gt;% arrange(-log_ratio) %&gt;% ggplot(aes(x = fct_rev(fct_inorder(term)), y = log_ratio)) + geom_col(fill = &quot;#D8A7B1&quot;) + theme_minimal() + coord_flip() + labs(title = &quot;STM beta matrix log ratios&quot;, subtitle = &quot;showing greatest differences in beta values&quot;, x = &quot;&quot;, y = &quot;log(beta ratio)&quot;) "],["sentiment-analysis.html", "1.1 Sentiment Analysis", " 1.1 Sentiment Analysis A typical sentiment analysis involves unnesting tokens with unnest_tokens(), assigning sentiments with inner_join(sentiments), counting tokens with count(), and summarizing and visualizing. The tidytext package contains four sentiment lexicons, all based on unigrams. nrc. binary “yes”/“no” for categories positive, negative, anger, anticipation, disgust, fear, joy, sadness, surprise, and trust. bing. “positive”/“negative” classification. AFINN. score between -5 (most negative) and 5 (most positive). loughran. “positive”/“negative”/“litigious”/“uncertainty”/“constraining”/“superflous” classification. You can view the sentiment assignments with get_sentiments(lexicon = c(\"afinn\", \"bing\", nrc\", \"laughlin\")) x1 &lt;- get_sentiments(lexicon = &quot;nrc&quot;) %&gt;% count(sentiment) %&gt;% mutate(lexicon = &quot;nrc&quot;) x2 &lt;- get_sentiments(lexicon = &quot;bing&quot;) %&gt;% count(sentiment) %&gt;% mutate(lexicon = &quot;bing&quot;) x3 &lt;- get_sentiments(lexicon = &quot;afinn&quot;) %&gt;% count(value) %&gt;% mutate(lexicon = &quot;afinn&quot;) %&gt;% mutate(sentiment = as.character(value)) %&gt;% select(-value) x4 &lt;- get_sentiments(lexicon = &quot;loughran&quot;) %&gt;% count(sentiment) %&gt;% mutate(lexicon = &quot;loughran&quot;) x &lt;- bind_rows(x1, x2, x3, x4) ggplot(x, aes(x = fct_reorder(sentiment, n), y = n, fill = lexicon)) + geom_col(show.legend = FALSE) + coord_flip() + labs(title = &quot;Sentiment Counts&quot;, x = &quot;&quot;, y = &quot;&quot;) + facet_wrap(~ lexicon, scales = &quot;free&quot;) Here is a sentiment analysis of sections of 80 lines of Jane Austin’s books. (Small sections may not have enough words to get a good estimate of sentiment, and large sections can wash out the narrative structure. 80 lines seems about right.) # austin_tidy %&gt;% # inner_join(get_sentiments(&quot;bing&quot;)) %&gt;% # count(book, index = linenumber %/% 80, sentiment) %&gt;% # pivot_wider(names_from = sentiment, values_from = n, values_fill = list(n = 0)) %&gt;% # mutate(sentiment = positive - negative) %&gt;% # ggplot(aes(x = index, y = sentiment, fill = book)) + # geom_col(show.legend = FALSE) + # facet_wrap(~book, ncol = 2, scales = &quot;free_x&quot;) Fair to say Jane Austin novels tend to have a happy ending? The three sentiment lexicons provide different views of THE data. Here is a comparison of the lexicons using one of Jane Austin’s novels, “Pride and Prejudice”. # # AFINN lexicon measures sentiment with a numeric score between -5 and 5. # afinn &lt;- austin_tidy %&gt;% # filter(book == &quot;Pride &amp; Prejudice&quot;) %&gt;% # inner_join(get_sentiments(&quot;afinn&quot;), by = &quot;word&quot;) %&gt;% # group_by(index = linenumber %/% 80) %&gt;% # summarise(sentiment = sum(value)) %&gt;% # mutate(method = &quot;AFINN&quot;) # # # Bing and nrc categorize words in a binary fashion, either positive or negative. # bing &lt;- austin_tidy %&gt;% # filter(book == &quot;Pride &amp; Prejudice&quot;) %&gt;% # inner_join(get_sentiments(&quot;bing&quot;), by = &quot;word&quot;) %&gt;% # count(index = linenumber %/% 80, sentiment) %&gt;% # pivot_wider(names_from = sentiment, values_from = n, values_fill = list(n = 0)) %&gt;% # mutate(sentiment = positive - negative) %&gt;% # mutate(method = &quot;Bing&quot;) %&gt;% # select(index, sentiment, method) # # nrc &lt;- austin_tidy %&gt;% # filter(book == &quot;Pride &amp; Prejudice&quot;) %&gt;% # inner_join(get_sentiments(&quot;nrc&quot;) %&gt;% filter(sentiment %in% c(&quot;positive&quot;, &quot;negative&quot;)), by = &quot;word&quot;) %&gt;% # count(index = linenumber %/% 80, sentiment) %&gt;% # pivot_wider(names_from = sentiment, values_from = n, values_fill = list(n = 0)) %&gt;% # mutate(sentiment = positive - negative) %&gt;% # mutate(method = &quot;NRC&quot;) %&gt;% # select(index, sentiment, method) # # bind_rows(afinn, bing, nrc) %&gt;% # ggplot(aes(index, sentiment, fill = method)) + # geom_col(show.legend = FALSE) + # facet_wrap(~method, ncol = 1, scales = &quot;free_y&quot;) In this example, and in general, NRC sentiment tends to be high, AFINN sentiment has more variance, and Bing sentiment finds longer stretches of similar text. However, all three agree roughly on the overall trends in the sentiment through a narrative arc. What are the top-10 positive and negative words? Using the Bing lexicon, get the counts, then group_by(sentiment) and top_n() to the top 10 in each category. # austin_tidy %&gt;% # filter(book == &quot;Pride &amp; Prejudice&quot;) %&gt;% # inner_join(get_sentiments(&quot;bing&quot;), by = &quot;word&quot;) %&gt;% # count(word, sentiment, sort = TRUE) %&gt;% # group_by(sentiment) %&gt;% # top_n(n = 10, wt = n) %&gt;% # ggplot(aes(x = fct_reorder(word, n), y = n, fill = sentiment)) + # geom_col(show.legend = FALSE) + # facet_wrap(~sentiment, scales = &quot;free_y&quot;) + # coord_flip() + # labs(y = &quot;Contribution to Sentiment&quot;, # x = &quot;&quot;) Uh oh, “miss” is a red-herring - in Jane Austin novels it often refers to an unmarried woman. Drop it from the analysis by appending it to the stop-words list. # austin_tidy %&gt;% # anti_join(bind_rows(stop_words, # tibble(word = c(&quot;miss&quot;), lexicon = c(&quot;custom&quot;)))) %&gt;% # filter(book == &quot;Pride &amp; Prejudice&quot;) %&gt;% # inner_join(get_sentiments(&quot;bing&quot;)) %&gt;% # count(word, sentiment, sort = TRUE) %&gt;% # group_by(sentiment) %&gt;% # top_n(n = 10, wt = n) %&gt;% # ggplot(aes(x = fct_reorder(word, n), y = n, fill = sentiment)) + # geom_col(show.legend = FALSE) + # facet_wrap(~sentiment, scales = &quot;free_y&quot;) + # coord_flip() + # labs(y = &quot;Contribution to Sentiment&quot;, # x = &quot;&quot;) Better! A common way to visualize sentiments is with a word cloud. # austin_tidy %&gt;% # anti_join(bind_rows(stop_words, # tibble(word = c(&quot;miss&quot;), lexicon = c(&quot;custom&quot;)))) %&gt;% # filter(book == &quot;Pride &amp; Prejudice&quot;) %&gt;% # count(word) %&gt;% # with(wordcloud(word, n, max.words = 100)) comparison.cloud is another implementation of a word cloud. It takes a matrix input. # x &lt;- austin_tidy %&gt;% # anti_join(bind_rows(stop_words, # tibble(word = c(&quot;miss&quot;), lexicon = c(&quot;custom&quot;)))) %&gt;% # inner_join(get_sentiments(&quot;bing&quot;)) %&gt;% # filter(book == &quot;Pride &amp; Prejudice&quot;) %&gt;% # count(word, sentiment, sort = TRUE) %&gt;% # pivot_wider(names_from = sentiment, values_from = n, values_fill = list(n = 0)) %&gt;% # as.data.frame() # rownames(x) &lt;- x[,1] # comparison.cloud(x[, 2:3]) # rm(x) Sometimes it makes more sense to analyze entire sentences. Specify unnest_tokens(..., token = \"sentences\") to override the default token = \"word\". # austen_books() %&gt;% # group_by(book) %&gt;% # mutate(linenumber = row_number(), # chapter = cumsum(str_detect(text, regex(&quot;^chapter [\\\\divxlc]&quot;, # ignore_case = TRUE)))) %&gt;% # ungroup() %&gt;% # unnest_tokens(output = word, input = text, token = &quot;sentences&quot;) 1.1.1 N-Grams Create n-grams by specifying unnest_tokens(..., token = \"ngrams\", n) where n = 2 is a bigram, etc. To remove the stop words, separate the n-grams, then filter on the stop_words data set. # austin.2gram &lt;- austen_books() %&gt;% # group_by(book) %&gt;% # mutate(linenumber = row_number(), # chapter = cumsum(str_detect(text, regex(&quot;^chapter [\\\\divxlc]&quot;, # ignore_case = TRUE)))) %&gt;% # ungroup() %&gt;% # unnest_tokens(output = bigram, input = text, token = &quot;ngrams&quot;, n = 2) # # austin.2gram &lt;- austin.2gram %&gt;% # separate(bigram, c(&quot;word1&quot;, &quot;word2&quot;), sep = &quot; &quot;) %&gt;% # filter(!word1 %in% stop_words$word &amp; # !word2 %in% stop_words$word &amp; # !is.na(word1) &amp; !is.na(word2)) %&gt;% # unite(bigram, word1, word2, sep = &quot; &quot;) # # austin.2gram %&gt;% # count(book, bigram, sort = TRUE) Here are the most commonly mentioned streets in Austin’s novels. # austin.2gram %&gt;% # separate(bigram, c(&quot;word1&quot;, &quot;word2&quot;), sep = &quot; &quot;) %&gt;% # filter(word2 == &quot;street&quot;) %&gt;% # count(book, word1, sort = TRUE) Use the TF-IDF statistic to compare words among documents. Calculate the cosine similarity, the angle in multidimensional space between two vectors (\\(cos(\\theta) = (A \\cdot B) / ||A||||B||)\\)), to determine how similar two items are. Use widyr::pairwise_similarity() to calculate the cosine similarity of all pairs of items in a tidy table. # austen %&gt;% # unnest_tokens(output = &quot;word&quot;, input = &quot;text&quot;, token = &quot;words&quot;) %&gt;% # anti_join(stop_words, by = &quot;word&quot;) %&gt;% # count(book, word) %&gt;% # bind_tf_idf(term = word, document = book, n = n) %&gt;% # pairwise_similarity(item = book, feature = word, value = tf_idf) %&gt;% # arrange(desc(similarity)) # austen_books() %&gt;% # group_by(book) %&gt;% # mutate(linenumber = row_number(), # chapter = cumsum(str_detect(text, regex(&quot;^chapter [\\\\divxlc]&quot;, # ignore_case = TRUE)))) %&gt;% # ungroup() %&gt;% # unnest_tokens(output = bigram, input = text, token = &quot;ngrams&quot;, n = 2) %&gt;% # separate(bigram, c(&quot;word1&quot;, &quot;word2&quot;), sep = &quot; &quot;) %&gt;% # filter(!word1 %in% stop_words$word &amp; # !word2 %in% stop_words$word &amp; # !is.na(word1) &amp; !is.na(word2)) %&gt;% # unite(bigram, word1, word2, sep = &quot; &quot;) # austin.2gram %&gt;% # count(book, bigram) %&gt;% # bind_tf_idf(bigram, book, n) %&gt;% # group_by(book) %&gt;% # top_n(n = 10, wt = tf_idf) %&gt;% # ggplot(aes(x = fct_reorder(bigram, n), y = tf_idf, fill = book)) + # geom_col(show.legend = FALSE) + # facet_wrap(~book, scales = &quot;free_y&quot;, ncol = 2) + # labs(y = &quot;tf-idf of bigram to novel&quot;) + # coord_flip() A good way to visualize bigrams is with a network graph. Packages igraph and ggraph provides tools for this purpose. # set.seed(2016) # # austen_books() %&gt;% # group_by(book) %&gt;% # mutate(linenumber = row_number(), # chapter = cumsum(str_detect(text, regex(&quot;^chapter [\\\\divxlc]&quot;, # ignore_case = TRUE)))) %&gt;% # ungroup() %&gt;% # unnest_tokens(output = bigram, input = text, token = &quot;ngrams&quot;, n = 2) %&gt;% # separate(bigram, c(&quot;word1&quot;, &quot;word2&quot;), sep = &quot; &quot;) %&gt;% # filter(!word1 %in% stop_words$word &amp; # !word2 %in% stop_words$word &amp; # !is.na(word1) &amp; !is.na(word2)) %&gt;% # count(word1, word2) %&gt;% # filter(n &gt; 20) %&gt;% # graph_from_data_frame() %&gt;% # creates unformatted &quot;graph&quot; # ggraph(layout = &quot;fr&quot;) + # geom_edge_link(aes(edge_alpha = n), # show.legend = FALSE, # arrow = grid::arrow(type = &quot;closed&quot;, # length = unit(.15, &quot;inches&quot;)), # end_cap = circle(.07, &#39;inches&#39;)) + # geom_node_point(color = &quot;lightblue&quot;, # size = 5) + # geom_node_text(aes(label = name), vjust = 1, hjust = 1) + # theme_void() If you want to count the number of times that two words appear within the same document, or to see how correlated they are, widen the data with the widyr package. # austen_books() %&gt;% # filter(book == &quot;Pride &amp; Prejudice&quot;) %&gt;% # mutate(section = row_number() %/% 10) %&gt;% # filter(section &gt; 0) %&gt;% # unnest_tokens(word, text) %&gt;% # filter(!word %in% stop_words$word) %&gt;% # pairwise_count(word, section, sort = TRUE) The correlation among words is how often they appear together relative to how often they appear separately. The phi coefficient is defined \\[\\phi = \\frac{n_{11}n_{00} - n_{10}n_{01}}{\\sqrt{n_{1.}n_{0.}n_{.1}n_{.0}}}\\] where \\(n_{10}\\) means number of times section has word x, but not word y, and \\(n_{1.}\\) means total times section has word x. This lets us pick particular interesting words and find the other words most associated with them. # austen_books() %&gt;% # filter(book == &quot;Pride &amp; Prejudice&quot;) %&gt;% # mutate(section = row_number() %/% 10) %&gt;% # filter(section &gt; 0) %&gt;% # unnest_tokens(word, text) %&gt;% # filter(!word %in% stop_words$word) %&gt;% # pairwise_cor(word, section, sort = TRUE) %&gt;% # filter(item1 %in% c(&quot;elizabeth&quot;, &quot;pounds&quot;, &quot;married&quot;, &quot;pride&quot;)) %&gt;% # group_by(item1) %&gt;% # top_n(n = 4) %&gt;% # ungroup() %&gt;% # mutate(item2 = reorder(item2, correlation)) %&gt;% # ggplot(aes(x = item2, y = correlation)) + # geom_bar(stat = &quot;identity&quot;) + # facet_wrap(~ item1, scales = &quot;free&quot;) + # coord_flip() You can use the correlation to set a threshold for a graph. 1.1.2 Converting to and from non-tidy formats One of the most common objects in text mining packages is the document term matrix (DTM) where each row is a document, each column a term, and each value an appearance count. The broom package contains functions to convert between DTM and tidy formats. Convert a DTM object into a tidy data frame with tidy(). Convert a tidy object into a sparse matrix with cast_sparse(), into a DTM with cast_dtm(), and into a “dfm” for quanteda with cast_dfm(). Create a tidy version of AssociatedPress with tidy(). The document-feature matrix dfm class from the quanteda text-mining package is another implementation of a document-term matrix. Here are the terms most specific (highest tf-idf) from each of four selected inaugural addresses. And here is word frequency trend ocer time for six selected terms. (problem with extract() below). Cast tidy data into document-term matrix with cast_dtm(), quanteda’s dfm with cast_dfm(), and sparese matrix with cast_sparse(). An untokenized document collection is called a corpus. The corpuse may include metadata, such as ID, date/time, title, language, etc. Corpus metadata is usually stored as lists. Use tidy() to construct a table, one row per document. 1.1.3 Example Library tm.plugin.webmining connects to online feeds to retrieve news articles based on a keyword. "],["text-classification-modeling.html", "1.2 Text Classification Modeling", " 1.2 Text Classification Modeling The tweets data set contains politically charged tweets. Can you train a model to predict the account_type (Left or Right) from the tweet text? Prepare the data by filtering to just the relevant tweets, tokenizing, and creatiing a document-term matrix with TFIDF weighting. If resources are an issue, experiment with values of parameter sparse in dt::removeSparseTerms() to get less terms. Below, sparse = 0.9999 finally gets a respectable term count 14% the size of the orginal count. Split the data into an 80:20 train:test split and fit a random forest model. "],["named-entity-recognition.html", "1.3 Named Entity Recognition", " 1.3 Named Entity Recognition The qdap package provides parsing tools for preparing transcript data. library(qdap) For example, freq_terms() parses text and counts the terms. You can also plot the terms. There are two kinds of the corpus data types, the permanent corpus, PCorpus, and the volatile corpus, VCorpus. The volatile corpus is held in RAM rather than saved to disk. Create a volatile corpus with tm::vCorpous(). vCorpous() takes either a text source created with tm::VectorSource() or a dataframe source created with Dataframe Source() where the input dataframe has cols doc_id, text_id and zero or more metadata columns. In bag of words text mining, cleaning helps aggregate terms, especially words with common stems like “miner” and “mining”. There are several functions useful for preprocessing: tolower(), tm::removePunctuation(), tm::removeNumbers(), tm::stripWhiteSpace(), and removeWords(). Apply these functions to the documents in a VCorpus object with tm_map(). If the function is not one of the pre-defined functions, wrap it in content_transformer(). Another preprocessing function is stemDocument(). The qdap package offers other preprocessing functions. tm::stopwords(\"en\") returns a vector of stop words. You can add to the list with concatenation. tm::stemDocument() and tm::stemCompletion() reduce the variation in terms. To perform the analysis of the tweets, convert the corpus into either a document term matrix (DTM, documents as rows, terms as cols), or a term document matrix (TDM, terms as rows, documents as cols). "],["tidy-text.html", "1.4 Tidy Text", " 1.4 Tidy Text Here are four Jane Austin books from the janeaustenr. “Sense &amp; Sensibility” acts as the baseline count, and the other books are faceted for comparison. "],["appendix-regular-expressions.html", "1.5 Appendix: Regular Expressions", " 1.5 Appendix: Regular Expressions There are two choices for string manipulation. Base R has grep() and gsub(). Or you can use the stringr package. Both will use the same regular expression patterns. Here are some important ones. 1.5.1 Base R grep() returns the indices of pattern matches in a vector of strings. Specify parameter value = TRUE to get the strings that match the pattern. str &lt;- c(&quot;abc123&quot;, &quot;xyz 789.&quot;) grep(&quot;\\\\w+123&quot;, str) # \\w any alphanumeric, + for any length ## [1] 1 grep(&quot;abc\\\\d&quot;, str) # \\d any digit ## [1] 1 grep(&quot;\\\\s&quot;, str) # s spaces, \\S non-spaces ## [1] 2 grep(&quot;\\\\.&quot;, str) # . anything, so \\. for period ## [1] 2 1.5.2 stringr The stringr package is a simple wrapper around the more complete stringi package. Example of finding rows in data frame of book text with “chapter [#]”. In regex(), “[]” means “any of”, “\\d” is any number, and “v”, “x”, “l”, and “c” are just roman numerals. Here is the word-count per chapter. austen &lt;- janeaustenr::austen_books() chapter_regex &lt;- stringr::regex(&quot;^chapter [\\\\divxlc]&quot;, ignore_case = TRUE) austen %&gt;% filter(book == &quot;Emma&quot;) %&gt;% mutate(linenumber = row_number(), chapter = cumsum(str_detect(text, chapter_regex))) %&gt;% ungroup() %&gt;% unnest_tokens(output = &quot;word&quot;, input = text, token = &quot;words&quot;) %&gt;% count(chapter) str_c() concatenates strings, similar to with paste() and paste0(). str_c(&quot;hello&quot;, &quot;world&quot;, sep = &quot; &quot;) ## [1] &quot;hello world&quot; str_replace(string, pattern, replacment) replaces pattern with replacement. str_replace(&quot;If the future&#39;s looking bleek&quot;, pattern = fixed(&quot;bleek&quot;), replacement = &quot;dark&quot;) ## [1] &quot;If the future&#39;s looking dark&quot; str_replace_na(string, replacement) replaces NAs. str_replace_na(c(&quot;We&#39;re the ones &quot;, NA, &quot;have to shine&quot;), replacement = &quot;who &quot;) ## [1] &quot;We&#39;re the ones &quot; &quot;who &quot; &quot;have to shine&quot; str_split(string, pattern, simplify = FALSE) splits string by pattern into a list of vectors, or matrix if simplify = TRUE. str_split(&quot;If there&#39;s no one in control&quot;, pattern = &quot; &quot;, simplify = TRUE) ## [,1] [,2] [,3] [,4] [,5] [,6] ## [1,] &quot;If&quot; &quot;there&#39;s&quot; &quot;no&quot; &quot;one&quot; &quot;in&quot; &quot;control&quot; str_c(..., sep) concatenates a vector of strings, separated by sep. str_c(&quot;we&#39;re&quot;, &quot;the&quot;, &quot;ones&quot;, &quot;who&quot;, &quot;draw&quot;, &quot;the&quot;, &quot;line&quot;, sep = &quot; &quot;) ## [1] &quot;we&#39;re the ones who draw the line&quot; str_sub(string, start, end) returns substring of string from start to end. Use negatives to start from the end of the string. my_str &lt;- &quot;Although we live in trying times&quot; str_sub(my_str, start = 1, end = 5) ## [1] &quot;Altho&quot; str_sub(my_str, start = -4, end = -1) ## [1] &quot;imes&quot; str_length(string) returns the number of characters in a string. str_length(&quot;We&#39;re the ones who have to try&quot;) ## [1] 30 str_detect(string, pattern) returns booleans where string matches pattern. str_detect(c(&quot;Although we know&quot;, &quot;that time&quot;, &quot;has wings&quot;), pattern = fixed(&quot;wings&quot;)) ## [1] FALSE FALSE TRUE str_match(string, pattern) returns matching strings where string matches pattern. str_match(c(&quot;Although we know&quot;, &quot;that time&quot;, &quot;has wings&quot;), pattern = &quot;wings&quot;) ## [,1] ## [1,] NA ## [2,] NA ## [3,] &quot;wings&quot; str_subset(string, pattern) returns string matches where string matches pattern. str_subset(c(&quot;Although we know&quot;, &quot;that time&quot;, &quot;has wings&quot;), pattern = fixed(&quot;wings&quot;)) ## [1] &quot;has wings&quot; str_count(string, pattern) returns a count of matches where string matches pattern. str_count(c(&quot;Although we know&quot;, &quot;that time&quot;, &quot;has wings&quot;), pattern = fixed(&quot;wings&quot;)) ## [1] 0 0 1 str_extract(string, pattern) returns the part of the string matching pattern. str_extract(c(&quot;We&#39;re the ones&quot;, &quot;who have to fly&quot;), pattern = &quot; t..&quot;) ## [1] &quot; the&quot; &quot; to &quot; 1.5.3 Regular Expressions The stringr package functions use ICU regular expressions. Here are common regular expressions. str_subset(sawyer$text, &quot;^tom&quot;) # starts with &quot;tom&quot; str_subset(sawyer$text, &quot;[0-9]&quot;) # contains a digit str_subset(sawyer$text, &quot;^[0-9]&quot;) # begins with a digit str_subset(sawyer$text, &quot;[^0-9]&quot;) # does not contain a digit str_subset(sawyer$text, &quot;.handsome.&quot;) # contains &quot;handsome&quot; sawyer %&gt;% filter(str_detect(sawyer$text, &quot;handsome&quot;)) # rows with &quot;handsome&quot; sawyer %&gt;% filter(str_detect(sawyer$text, &quot;.handsome.&quot;)) # same thing # Using perl-style regexp, # &quot;(.)&quot; is a subexpression (defined with parens) consisting of any character # defined with a dot. &quot;\\\\U&quot; makes the next character uppercase. \\\\1 is a # reference to subexpression 1 sub(&quot;(.)&quot;, (&quot;\\\\U\\\\1&quot;), sawyer_tokens$word, perl=TRUE) str_to_title(sawyer_tokens$word) # nearly the same - converts first letter, not char str_to_title(sawyer$text) # [] defines a set of chars str_subset(sawyer$text, &quot;^[qQ]&quot;) # starts with &quot;q&quot; or &quot;Q&quot; str_subset(sawyer$text, &quot;(^[\\\\_])(.*-)&quot;) # starts with &quot;_&quot; and contains &quot;-&quot; str_subset(sawyer$text, &quot;dog.*tricks|tricks.*dog&quot;) # contains &quot;dog&quot; &amp; &quot;tricks&quot; "],["appendix-tidytext.html", "1.6 Appendix: tidytext", " 1.6 Appendix: tidytext The tidy text format is a table with one token (meaningful unit of text, such as a word) per row. The tidytext package assists with the major tasks in text analysis. A typical text analysis using tidy data principles unnests tokens with unnest_tokens(), anti-joins unimportant “stop words” from tidytext::stop_words, and summarizes token counts count(). In between you might also reduce words to their stems with SnowballC::wordStem(). Summarize the tidy text into a “bag of words” (table of word frequencies). Once in a bag of words format, you can feed into a word cloud or other ggplot geom. To perform topic modeling, cast the bag of words into a document term matrix with cast_dtm(). After performing a topic model, cast the output (either a beta matrix or gamma matrix) into tidy format with tidy(). "],["appendix-tm.html", "1.7 Appendix: tm", " 1.7 Appendix: tm The Text Mining package tm is a text mining framework for importing data, handling a corpus, and creating term-document matrices. The main structure document structure is a corpus, implemented either as an in-memory volatile corpus VCorpus() or on-disk permanent corpus Pcorpus(). Create a corpus from a directory of text documents my_rmd_corpus &lt;- VCorpus(DirSource(pattern = &quot;*.Rmd&quot;)) or from a data frame using helper function VectorSource(). A corpus is a list of document objects, each containing meta data and content. Here is the first document of the one I just created. You can perform transformations on your tm object, including removing extra whitespace tm_map(x, stripWhitespace), converting to lowercase tm_map(x, content_transformer(tolower)), removing stopwords tm_map(x, removeWords, stopwords(\"english\")), and stemming tm_map(x stemDocument). Some packages (e.g., topicmodels) operate on a “bag of words” representation called a document term matrix. A bag of words is a frequency count of words. Convert the tm object into a matrix with TermDocumentMatrix() or DocumentTermMatrix() (the first presents terms as rows and documents as columns). Here is a quick analysis of the Russian Tweets data loaded at the beginning of the chapter. "],["references.html", "References", " References "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
