# Regularization

These notes are from this [tutorial](https://www.datacamp.com/community/tutorials/tutorial-ridge-lasso-elastic-net) on DataCamp, the [Machine Learning Toolbox](https://campus.datacamp.com/courses/machine-learning-toolbox) DataCamp class, and Interpretable Machine Learning [@Molner2020].

Regularization is a set of methods that manage the bias-variance trade-off problem in linear regression. 

The linear regression model is $Y = X \beta + \epsilon$, where $\epsilon \sim N(0, \sigma^2)$. OLS estimates the coefficients by minimizing the loss function,

$$L = \left(y - X \hat{\beta}\right)^2.$$

The resulting estimate for the coefficients is 

$$\hat{\beta} = \left(X'X\right)^{-1}\left(X'Y\right).$$

There are two important characteristics of any estimator: its *bias* and its *variance*.  For OLS, these are

$$Bias(\hat{\beta}) = E(\hat{\beta}) - \beta = 0$$
$$Var(\hat{\beta}) = \sigma^2(X'X)^{-1}$$

where the unknown population variance $\sigma^2$ is estimated from the residuals

$$\hat\sigma^2 = \frac{\epsilon' \epsilon}{n - k}.$$

The OLS estimator is unbiased, but can have a large variance when the predictor variables are highly correlated with each other, or when there are many predictors (notice how $\hat{\sigma}^2$ increases as $k \rightarrow n$).  Stepwise selection balances the trade-off by eliminating variables, but this throws away information.  *Regularization* keeps all the predictors, but reduces coefficient magnitudes to reduce variance at the expense of some bias.

In the sections below, I'll use the `cars` data set to predict `mpg` from the other variables using the `caret::glmnet()` function.  `glmnet()` uses penalized maximum likelihood to fit generalized linear models such as ridge, lasso, and elastic.  I'll compare the model performances by creating a training and validation set, and a common `trainControl` object to make sure the models use the same observations in the cross-validation folds.

```{r warning=FALSE, message=FALSE}
library(tidyverse)
library(caret)

data("mtcars")

set.seed(123)
partition <- createDataPartition(mtcars$mpg, p = 0.6, list = FALSE)
training <- mtcars[partition, ]
testing <- mtcars[-partition, ]

train_control <- trainControl(
  method = "cv",
  number = 5,  # number of folds, usually 10, but 5 for smaller data sets
#  index = createFolds(training$mpg, k = 5),  # specify the fold index
#  verboseIter = FALSE,  # don't print the results to the log
  savePredictions = "final"  # saves predictions for the optimal tuning parameters
)
```


## Ridge

Ridge regression estimates the linear model coefficients by minimizing an augmented loss function which includes a term, $\lambda$, that penalizes the magnitude of the coefficient estimates,

$$L = \left(y - X \hat{\beta}\right)^2 + \lambda\hat\beta^2.$$

The resulting estimate for the coefficients is 

$$\hat{\beta} = \left(X'X + \lambda I\right)^{-1}\left(X'Y \right).$$

As $\lambda \rightarrow 0$, ridge regression approaches OLS.  The bias and variance for the ridge estimator is

$$Bias(\hat{\beta}) = -\lambda \left(X'X + \lambda I \right)^{-1} \beta$$
$$Var(\hat{\beta}) = \sigma^2 \left(X'X + \lambda I \right)^{-1}X'X \left(X'X + \lambda I \right)^{-1}$$

The estimator bias increases with $\lambda$ and the estimator variance decreases with $\lambda$.  The optimal level for $\lambda$ that balances the trade-off is the one that minimizes some criterion with cross-validation, usually the root mean squared error (RMSE), but you can also try the Akaike or Bayesian Information Criterion (AIC or BIC), or R-squared.


#### Example {-}

Specify `alpha = 0` in a tuning grid for ridge regression (the following sections reveal how alpha distinguishes ridge, lasso, and elastic net).

```{r}
set.seed(1234)
mdl_ridge <- train(
  mpg ~ .,
  data = training,
  method = "glmnet",
  metric = "RMSE",  # Choose from RMSE, RSquared, AIC, BIC, ...others?
  preProcess = c("zv",  # remove and variables with zero variance (a single value)
                 "medianImpute",   # impute NAs with median (then try knnImpute!)
                 "center", "scale"  # standardize data for linear models "it just works better."
                # "pca"  # reduce dimensions of nearly-zero variance columns
                 ),  
  tuneGrid = expand.grid(
    .alpha = 0,  # optimize a ridge regression
    .lambda = seq(2, 8, length = 20)),  # create range by experiment to find metric's local min
  trControl = train_control
  )
mdl_ridge
```

The model printout shows the RMSE, R-Squared, and mean absolute error (MAE) values at each lambda specified in the tuning grid.  The final three lines summarize what happened.  It did not tune alpha because I held it at 0 for ridge regression; it optimized using RMSE; and the optimal tuning values (at the mimimum RMSE) were alpha = 0 and lambda = 0.2222.  You can see the RMSE minimum with the plot.

```{r}
plot(mdl_ridge, main = "Ridge Regression Parameter Tuning", xlab = "lambda")
```

Make predictions on the validation data set and save the performance metrics for comparison to other models.  

```{r}
(ridge.perf <- postResample(pred = predict(mdl_ridge, newdata = testing), 
                            obs = testing$mpg))
```

On average, this model will miss the true value of `mpg` by 2.994 mpg (RMSE) or 2.418 mpg (MAE).  The model explains about 82% of the variation in `mpg`.

```{r}
varImp(mdl_ridge$finalModel)
```


## Lasso

Lasso stands for “least absolute shrinkage and selection operator”.  Like ridge, lasso adds a penalty for coefficients, but instead of penalizing the sum of squared coefficients (L2 penalty), lasso penalizes the sum of absolute values (L1 penalty). As a result, for high values of $\lambda$, coefficients can be zeroed under lasso.

The loss fuction for lasso is

$$L_{ridge} = ||y - X \hat{\beta}||^2 + \lambda||\hat\beta||.$$

#### Example {-}

Continuing with prediction of `mpg` from the other variables in the `mtcars` data set, follow the same steps as before, but with ridge regression.  This time specify parameter `alpha = 1` for ridge regression (it was 0 for ridge, and for elastic net it will be something in between and require optimization).  Specify `standardize = TRUE` again to standardize the predictor matrix.

```{r}
set.seed(123)
mdl_lasso <- train(
  mpg ~ .,
  data = training,
  method = "glmnet",
  metric = "RMSE",  # Choose from RMSE, RSquared, AIC, BIC, ...others?
  preProcess = c("zv",  # remove and variables with zero variance (a single value)
                 "medianImpute",   # impute NAs with median (then try knnImpute!)
                 "center", "scale",  # standardize data for linear models "it just works better."
                 "pca"  # reduce dimensions of nearly-zero variance columns
                 ),  
  tuneGrid = expand.grid(
    .alpha = 1,  # optimize a lasso regression
    .lambda = seq(0, 10, length = 100)),  # create range by experiment to find metric's local min
  trControl = train_control
  )
mdl_lasso
```

The suumary output shows the model did not tune alpha because I held it at 1 for lasso regression; it optimized using RMSE; and the optimal tuning values (at the miminum RMSE) were alpha = 1 and lambda = 1.3.  You can see the RMSE minimum on the the plot.

```{r}
plot(mdl_lasso, main = "Lasso Regression Parameter Tuning", xlab = "lambda")
```

Make predictions on the validation data set and save the performance metrics for comparison to other the models.  

```{r}
(lasso.perf <- postResample(pred = predict(mdl_lasso, newdata = testing), 
                            obs = testing$mpg))
```

On average, this model will miss the true value of `mpg` by 1.90 mpg (RMSE) or 1.64 mpg (MAE), so better than ridge on the RMSE measure and the MAE measure.  RMSE penalizes outliers more, so this model does a better job on the outiers and on the non-outliers.  The model explains about 85% of the variation in `mpg`, same as ridge.


## Elastic Net

Elastic Net combines the penalties of ridge and lasso to get the best of both worlds. The loss fuction for elastic net is

$$L_{enet} = \frac{||y - X \hat{\beta}||^2}{2n} + \lambda \frac{1 - \alpha}{2}||\hat\beta||^2 + \lambda \alpha||\hat\beta||.$$

In this loss function, new parameter $\alpha$ is a "mixing" parameter that balances the two approaches.  You can see that if $\alpha$ is zero, you are back to ridge regression, and if $\alpha$ is one, you are back to lasso.


#### Example {-}

Continuing with prediction of `mpg` from the other variables in the `mtcars` data set, follow the same steps as before, but with elastic net regression.  This time there are two parameters to optimize: $\lambda$ and $\alpha$.

Tuning parameters:
`alpha`: mixing percentage
`lambda`: regularization

Set the train control to do *5*-fold cross-validation.  

```{r}
set.seed(12345)
mdl_elnet <- train(
  mpg ~ .,
  data = training,
  method = "glmnet",
  metric = "RMSE",  # Choose from RMSE, RSquared, AIC, BIC, ...others?
  tuneLength = 25,  # Do not choose values - let the algorith search for them
  preProcess = c("zv",  # remove and variables with zero variance (a single value)
                 "medianImpute",   # impute NAs with median (then try knnImpute!)
                 "center", "scale",  # standardize data for linear models "it just works better."
                 "pca"  # reduce dimensions of nearly-zero variance columns
                 ),  
  trControl = train_control
  )
mdl_elnet
```

The suumary output shows the model optimized using RMSE; and the optimal tuning values (at the miminum RMSE) were alpha = 1.0 and lambda = 1.42, so the mix is 0% ridge, 100% lasso, and the penalization lambda is 1.42.  You can see the RMSE minimum on the the plot.  Alpha is on the horizontal axis and the different lambdas are shown as separate series.  

```{r}
plot(mdl_elnet, main = "Elastic Net Regression Parameter Tuning")
```

Make predictions on the validation data set and save the performance metrics for comparison to other the models.  

```{r}
(elnet.perf <- postResample(pred = predict(mdl_elnet, newdata = testing), 
                            obs = testing$mpg))
```

On average, this model will miss the true value of `mpg` by 1.91 mpg (RMSE) or 1.68 mpg (MAE), so in between the ridge and lasso models already fit.  The model explains about 84% of the variation in `mpg`, slightly less than ridge and lasso.


## Model Summary

Here are the results of the three regularization methods.

```{r}
rbind(ridge.perf, lasso.perf, elnet.perf)
```

It looks like lasso was the big winner today based on RMSE and MAE.  Ridge pulled out the victory on Rsquared.  In general, lasso performs well when there are only a few significant parameters and ridge performs well when many parameters are significant.  You won't know which model is best in advance because you won't know how many parameters are significant.  Just try all three models.

You can also compare the models by resampling.  

```{r}
model.resamples <- resamples(list(Ridge = mdl_ridge,
                                  Lasso = mdl_lasso,
                                  ELNet = mdl_elnet))
summary(model.resamples)
```

You want the smallest mean RMSE, and a small range of RMSEs.  Lasso had the smallest mean, and a relatively small range.  Boxplots are a common way to visualize this information.  

```{r}
bwplot(model.resamples, metric = "RMSE", main = "Model Comparison on Resamples")
```

Now that you have identified the optimal model, capture its tuning parameters and refit the model to the entire data set.

```{r}
set.seed(123)
final.model <- train(
  mpg ~ .,
  data = training,
  method = "glmnet",
  metric = "RMSE",  # Choose from RMSE, RSquared, AIC, BIC, ...others?
  preProcess = c("medianImpute",   # impute NAs with median (then try knnImpute!)
                 "center", "scale"),  # standardize data for linear models "it just works better."
  tuneGrid = data.frame(
    .alpha = mdl_lasso$bestTune$alpha,  # optimized hyperparameters
    .lambda = mdl_lasso$bestTune$lambda),  # optimized hyperparameters
  trControl = train_control
  )
final.model
```

The model is ready to predict on new data!

